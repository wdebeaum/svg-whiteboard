<!DOCTYPE html>
<html xmlns:xlink="http://www.w3.org/1999/xlink"><head>
<meta charset="UTF-8">
<title>SVG Whiteboard</title>
<style type="text/css" id="icon-style">
@font-face {
  font-family: 'Symbola';
  src: url('data:font/woff;charset=utf-8;base64,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') format('woff');
}
.icon {
  font-family: Symbola;
  font-size: 16pt;
  cursor: pointer;
  shape-rendering: crispEdges;
}
circle.icon {
  shape-rendering: auto;
}
.cursor {
  filter: url(#outline);
}
.cursor #select-icon {
  fill: none;
  stroke: black;
  stroke-width: 1px;
  stroke-dasharray: 3px,2px;
}
</style>
<style type="text/css">
html, body, svg {
  width: 100%;
  height: 100%;
  margin: 0;
  overflow: hidden;
}
#svg-container {
  position: absolute;
  width: 100%;
  top: 0;
  margin: 0;
  overflow: hidden;
}
.clicked.icon {
  stroke: white;
}
circle.clicked.icon {
  fill: white;
}
.select-icon-use {
  fill: none;
  stroke-width: 1px;
  stroke-dasharray: 3px,2px;
}
.select-icon-use.unclicked.icon {
  stroke: black;
}
.select-icon-use.clicked.icon {
  stroke: white;
}
#select-rect {
  fill: none;
  stroke: black;
  stroke-width: 1px;
  stroke-dasharray: 3px,2px;
}
#zoom-factor {
  fill: black;
  font-family: Symbola;
  font-size: 16px;
}
.color {
  stroke: white;
  stroke-width: 2px;
  cursor: pointer;
}
.frame {
  stroke: black;
  stroke-width: 1px;
  cursor: pointer;
  shape-rendering: crispEdges;
}
.unclicked.frame {
  fill: #ddd;
}
.clicked.frame {
  fill: black;
}
text {
  font-family: Symbola;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
#text-tool-input {
  font-family: Symbola;
  position: absolute;
}
#doc-and-selection path { /* freehand */
  fill: none;
  stroke-linejoin: round;
  stroke-linecap: round;
}
#doc-and-selection line { /* arrows */
  marker-end: url('#arrow-head');
}
#selection-filter {
  filter: url('#shadow');
}
.popup {
  filter: url('#fat-outline');
}
div.popup {
  position: absolute;
  left: 64px; top: 64px; bottom: 64px; right: 64px;
  padding: 1em;
  background-color: #ddd;
  border: 1px solid black;
  font-family: Symbola;
  overflow: auto;
  filter: none; /* work around bug in Firefox */
}
.close {
  position: fixed;
  top: 32px;
  right: 32px;
  width: 32px;
  height: 32px;
  background-color: red;
  border: 1px solid black;
  color: white;
  font-family: Symbola;
  font-size: 24pt;
  text-align: center;
  vertical-align: middle;
  cursor: pointer;
}
dt {
  font-weight: bold;
}
.inline {
  display: inline;
}
.inline.icon {
  font-weight: normal;
  width: 32px;
  height: 32px;
  vertical-align: middle;
}
.invisible {
  display: none;
}
input[type="number"] {
  width: 4em;
  text-align: right;
}
input[type="color"] {
  vertical-align: middle;
}
input[type="url"] {
  width: 100%;
}
#ice-servers {
  width: 100%;
}
#collaboration-bar {
  background-color: #ddd;
  border: 1px solid black;
  position: absolute;
  left: 0;
  bottom: 0;
  right: 0;
  height: 14ex;
}
#text-chat {
  position: absolute;
  left: 0;
  bottom: 0;
  top: 0;
  right: 20%;
}
#text-chat-history {
  position: absolute;
  overflow-y: scroll;
  top: 0;
  width: 100%;
  height: 12ex;
}
#text-chat-input {
  position: absolute;
  width: 100%;
  bottom: 0;
  height: 2ex;
  border: 0;
  padding: 0;
}
#user-status {
  position: absolute;
  overflow: auto;
  right: 0;
  top: 0;
  bottom: 0;
  left: 80%;
}
.user-status-list {
  margin-top: 0;
  margin-bottom: 0;
  padding-left: 1.5em;
}
.user-status-list li span {
  color: black;
}
.user-status-list li.active {
  color: green;
}
.user-status-list li.inactive {
  color: orange;
  list-style-type: square;
}
.user-status-list li.disconnected {
  color: #888;
  list-style-type: circle;
}
.user-status-list.demo {
  float: right;
  border: 1px solid black;
}
</style>
<script type="text/javascript">

//// OO ////

function defineMethods(constructor, methods) {
  methods.map(function(fn) { constructor.prototype[fn.name] = fn; });
}

//// general UI manipulation ////

function show(elem) {
  elem.style.display = '';
}

function hide(elem) {
  elem.style.display = 'none';
}

function isHidden(elem) {
  return (elem.style.display == 'none');
}

function setDisplay(elem, shown) {
  if (shown) {
    show(elem);
  } else {
    hide(elem);
  }
}

function toggleDisplay(elem) {
  setDisplay(elem, isHidden(elem));
}

function forEachChildClassName(elem, fn) {
  var cs = elem.childNodes;
  for (var i = 0; i < cs.length; i++) {
    if (!('getAttribute' in cs[i])) {
      continue;
    }
    var cn = cs[i].getAttribute('class');
    if (cn === undefined || cn === null) {
      continue;
    }
    cn = cn.toString();
    if (!fn(cn, cs[i])) {
      return false;
    }
  }
  return true;
}

function isButtonClicked(elem) {
  var ret = false;
  forEachChildClassName(elem, function(className, childNode) {
    if (/\bunclicked\b/.test(className)) {
      return false;
    } else if (/\bclicked\b/.test(className)) {
      ret = true;
      return false;
    }
    return true;
  });
  return ret;
}

function makeButtonClicked(elem) {
  forEachChildClassName(elem, function(className, childNode) {
    if (/\bunclicked\b/.test(className)) {
      className = className.replace(/\bunclicked\b/, 'clicked');
      childNode.setAttribute('class', className);
    }
    return true;
  });
  return true;
}

function makeButtonUnclicked(elem) {
  forEachChildClassName(elem, function(className, childNode) {
    if (/\bclicked\b/.test(className)) {
      className = className.replace(/\bclicked\b/, 'unclicked');
      childNode.setAttribute('class', className);
    }
    return true;
  });
  return true;
}

function toggleButtonClickedness(elem) {
  // replace occurrences of "clicked" class with "unclicked" and vice versa
  forEachChildClassName(elem, function(className, childNode) {
    if (/\bunclicked\b/.test(className)) {
      className = className.replace(/\bunclicked\b/, 'clicked');
    } else if (/\bclicked\b/.test(className)) {
      className = className.replace(/\bclicked\b/, 'unclicked');
    } else {
      return true;
    }
    childNode.setAttribute('class', className);
    return true;
  });
}

function forEachToolbarButton(elem, fn) {
  for (var i = 0; i < elem.childNodes.length; i++) {
    var button = elem.childNodes[i];
    if ((!('childNodes' in button)) || button.childNodes.length < 2) {
      continue;
    }
    if (!fn(button)) {
      return false;
    }
  }
  return true;
}

function makeToolbarUnclicked(elem) {
  forEachToolbarButton(elem, function(button) {
    makeButtonUnclicked(button);
    return true;
  });
}

//// stateful stuff ////

var svgNS = "http://www.w3.org/2000/svg";
var xlinkNS = "http://www.w3.org/1999/xlink";
var svg = undefined;
var iconStyle = undefined;
var currentTool = 'draw';
var currentSize = 5;
var currentColor = '#0000c0';
var draggedObject = null;
var deferredMovement = null;
var dragging = false;
var mouseIsOverUI = false;
var actionsToUndo = [];
var actionsToRedo = [];
var currentAction = undefined;
var peerConnections = {};
var collaborationHub = undefined;

// given an element, ensure it has an ID, and return its ID
var nextIDNumber = 0;
function ensureID(element) {
  while (!element.id) {
    var nextID = (localUserName.value || 'E') + nextIDNumber;
    nextIDNumber++;
    if (!document.getElementById(nextID)) {
      element.id = nextID;
    }
  }
  return element.id;
}

function ensureIDs(elements) {
  return elements.map(function(e) { return ensureID(e); });
}

function getElementsByIds(ids) {
  return ids.map(function(id) { return document.getElementById(id); });
}

/* like svg.checkEnclosure, but:
 *  - only check against the bounding box
 *  - assume no rotations or negative scales have been applied
 * (also Firefox doesn't have checkEnclosure yet)
 */
function checkBBEnclosure(element, rect) {
  var localBB = element.getBBox();
  var localTL = svg.createSVGPoint();
  localTL.x = localBB.x;
  localTL.y = localBB.y;
  var localBR = svg.createSVGPoint();
  localBR.x = localBB.x + localBB.width;
  localBR.y = localBB.y + localBB.height;
  var m = element.getCTM();
  var viewTL = localTL.matrixTransform(m);
  var viewBR = localBR.matrixTransform(m);
  var rectBR = { x: rect.x + rect.width, y: rect.y + rect.height };
  return (rect.x <= viewTL.x && rect.y <= viewTL.y &&
          rectBR.x >= viewBR.x && rectBR.y >= viewBR.y);
}

/* like svg.getBBEnclosureList, but:
 *  - only check against each element's bounding box
 *  - assume no rotations or negative scales have been applied
 *  - only check children of referenceElement, not all descendants
 *  - return a simple Array instead of a live NodeList
 * (also Firefox doesn't have getEnclosureList yet)
 */
function getBBEnclosureList(rect, referenceElement) {
  var cs = referenceElement.childNodes;
  var ret = [];
  for (var i = 0; i < cs.length; i++) {
    if ('getBBox' in cs[i] && checkBBEnclosure(cs[i], rect)) {
      ret.push(cs[i]);
    }
  }
  return ret;
}

// given the ID of an icon, call the callback with a CSS cursor declaration
// using the icon (can't just return it because we need to "load" an image from
// a data URL into a canvas...)
function iconToCursor(iconId, callback) {
  // It would be nice if this were just "cursor: url(#" + iconID + ");", but
  // that's not the world we live in :-P
  var iconDef = document.getElementById(iconId);
  var hotspot = "16 16";
  if (iconDef.hasAttribute("hotspot")) {
    hotspot = iconDef.getAttribute("hotspot");
  }
  var iconSVG =
    '<?xml version="1.0"?>' +
    '<svg xmlns="http://www.w3.org/2000/svg" width="32px" height="32px">' +
    '<defs>' +
    iconStyle +
    // ... but it also means we have an opportunity to put filter effects on
    // the icon like this
    document.getElementById('outline').outerHTML +
    '</defs>' +
    '<g class="cursor icon">' +
    iconDef.outerHTML +
    '</g>' +
    '</svg>';
  // render iconSVG to the cursor canvas and read it back out as a PNG
  var canvas = document.getElementById('cursor-canvas');
  var ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  var img = new Image();
  var url = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(iconSVG);
  img.onload = function() {
    ctx.drawImage(img,0,0);
    callback("cursor: url('" + canvas.toDataURL('image/png') + "') " + hotspot + ", auto;");
  };
  img.src = url;
}

//// coordinate transformations ////

function getEventCoordsRelativeToDoc(e) {
  var pageCoords = svg.createSVGPoint();
  pageCoords.x = e.pageX;
  pageCoords.y = e.pageY;
  var transforms = doc.transform.animVal;
  var m = transforms.getItem(1).matrix.inverse().multiply(
          transforms.getItem(0).matrix.inverse());
  var docCoords = pageCoords.matrixTransform(m);
  return docCoords;
}

function getDocCoordsRelativeToPage(docCoords) {
  if (!(docCoords instanceof SVGPoint)) {
    var point = svg.createSVGPoint();
    point.x = docCoords.x;
    point.y = docCoords.y;
    docCoords = point;
  }
  var transforms = doc.transform.animVal;
  var m = transforms.getItem(0).matrix.multiply(transforms.getItem(1).matrix);
  var pageCoords = docCoords.matrixTransform(m);
  return pageCoords;
}

function getPageMovementRelativeToDoc(pageMovement) {
  var scaleVal = doc.transform.baseVal.getItem(1).matrix.a;
  var docMovement = {
    x: pageMovement.x / scaleVal,
    y: pageMovement.y / scaleVal
  };
  return docMovement;
}

function copyDocTransformToSelection() {
  selection.setAttribute("transform", doc.getAttribute("transform"));
}

//// action steps ////

function AddObject(o) {
  this.addedObject = o;
}
defineMethods(AddObject, [
  function undo() { this.addedObject.remove(); },
  function redo() { doc.appendChild(this.addedObject); },
  function describe() {
    ensureID(this.addedObject);
    return { type: 'addObjects', outerHTML: this.addedObject.outerHTML };
  },
  function undescribe() {
    return { type: 'deleteObjects', ids: [ensureID(this.addedObject)] };
  }
]);

function ensureArray(collection) {
  var ret = [];
  if (collection instanceof NodeList) {
    // copy NodeList to Array to make it not a live collection
    for (var i = 0; i < collection.length; i++) {
      ret.push(collection[i]);
    }
  } else if (collection instanceof Array) {
    ret = collection;
  } else if (collection) {
    ret = [collection];
  }
  return ret;
}

function DeleteObjects(o) {
  this.deletedObjects = ensureArray(o);
}
defineMethods(DeleteObjects, [
  function add(o) {
    this.deletedObjects = this.deletedObjects.concat(ensureArray(o));
  },
  function undo() {
    for (var i = 0; i < this.deletedObjects.length; i++) {
      doc.appendChild(this.deletedObjects[i]);
    }
  },
  function redo() {
    for (var i = 0; i < this.deletedObjects.length; i++) {
      this.deletedObjects[i].remove();
    }
  },
  function describe() {
    return { type: 'deleteObjects',
      ids: this.deletedObjects.map(function(o) { return ensureID(o); })
    };
  },
  function undescribe() {
    ensureIDs(this.deletedObjects);
    return { type: 'addObjects',
      outerHTML: this.deletedObjects.
        map(function(o) { return o.outerHTML; }).
	reduce(function(p, c) { return p + c; }, '')
    };
  }
]);

function MoveObjects(o) {
  this.movedObjects = ensureArray(o);
  this.movement = { x: 0, y: 0 };
}
defineMethods(MoveObjects, [
  function add(currentMovement) {
    this.movement.x += currentMovement.x;
    this.movement.y += currentMovement.y;
  },
  function nonzero() {
    return (this.movement.x != 0 && this.movement.y != 0);
  },
  function negativeMovement() {
    return { x: -this.movement.x, y: -this.movement.y };
  },
  function undo() {
    moveObjects(this.movedObjects, this.negativeMovement());
  },
  function redo() {
    moveObjects(this.movedObjects, this.movement);
  },
  function describe() {
    return { type: 'moveObjects',
      ids: this.movedObjects.map(function(o) { return o.id; }),
      movement: this.movement
    };
  },
  function undescribe() {
    return { type: 'moveObjects',
      ids: this.movedObjects.map(function(o) { return o.id; }),
      movement: this.negativeMovement()
    };
  }
]);

function SizeObjects(o, newSize) {
  this.sizedObjects = ensureArray(o);
  this.oldSizes = [];
  for (var i = this.sizedObjects.length-1; i >= 0; i--) {
    this.oldSizes[i] = getObjectSize(this.sizedObjects[i]);
  }
  this.newSize = newSize;
}
defineMethods(SizeObjects, [
  function undo() {
    for (var i = this.sizedObjects.length-1; i >= 0; i--) {
      setObjectSize(this.sizedObjects[i], this.oldSizes[i]);
    }
  },
  function redo() {
    for (var i = this.sizedObjects.length-1; i >= 0; i--) {
      setObjectSize(this.sizedObjects[i], this.newSize);
    }
  },
  function describe() {
    return { type: 'sizeObjects',
      ids: ensureIDs(this.sizedObjects),
      size: this.newSize
    };
  },
  function undescribe() {
    return { type: 'sizeObjects',
      ids: ensureIDs(this.sizedObjects),
      sizes: this.oldSizes
    };
  }
]);

function ColorObjects(o, newColor) {
  this.coloredObjects = ensureArray(o);
  this.oldColors = [];
  for (var i = this.coloredObjects.length-1; i >= 0; i--) {
    this.oldColors[i] = getObjectColor(this.coloredObjects[i]);
  }
  this.newColor = newColor;
}
defineMethods(ColorObjects, [
  function undo() {
    for (var i = this.coloredObjects.length-1; i >= 0; i--) {
      setObjectColor(this.coloredObjects[i], this.oldColors[i]);
    }
  },
  function redo() {
    for (var i = this.coloredObjects.length-1; i >= 0; i--) {
      setObjectColor(this.coloredObjects[i], this.newColor);
    }
  },
  function describe() {
    return { type: 'colorObjects',
      ids: ensureIDs(this.coloredObjects),
      color: this.newColor
    };
  },
  function undescribe() {
    return { type: 'colorObjects',
      ids: ensureIDs(this.coloredObjects),
      colors: this.oldColors
    };
  }
]);

//// actions ////

function startAction(firstStep) {
  currentAction = [];
  if (firstStep) {
    addToAction(firstStep);
  }
}

// takes a step with methods undo() and redo()
function addToAction(step) {
  currentAction.push(step);
}

function cancelAction() {
  currentAction = undefined;
}

function finishAction() {
  actionsToUndo.push(currentAction);
  actionsToRedo = [];
  sendAction(currentAction);
}

function undoAction() {
  var action = actionsToUndo.pop();
  if (action) {
    console.log('undoing action ' + JSON.stringify(action.map(function(a) { return a.describe(); })));
    for (var i = action.length-1; i >= 0; i--) {
      action[i].undo();
    }
    actionsToRedo.push(action);
    unsendAction(action);
  }
}

function redoAction() {
  var action = actionsToRedo.pop();
  if (action) {
    console.log('redoing action ' + JSON.stringify(action.map(function(a) { return a.describe(); })));
    for (var i = 0; i < action.length; i++) {
      action[i].redo();
    }
    actionsToUndo.push(action);
    sendAction(action);
  }
}

function sendAction(action) {
  if (Object.keys(peerConnections).length > 0) {
    var descriptions = action.map(function(a) { return a.describe(); });
    for (var remoteUser in peerConnections) {
      if (peerConnections[remoteUser].isOpen) {
	for (var i = 0; i < descriptions.length; i++) {
	  peerConnections[remoteUser].send(descriptions[i]);
	}
      }
    }
  }
}

function unsendAction(action) {
  if (Object.keys(peerConnections).length > 0) {
    var descriptions = action.map(function(a) { return a.undescribe(); });
    for (var remoteUser in peerConnections) {
      if (peerConnections[remoteUser].isOpen) {
	for (var i = descriptions.length-1; i >= 0; i--) {
	  peerConnections[remoteUser].send(descriptions[i]);
	}
      }
    }
  }
}

function receiveStep(data) {
  // TODO fold these into the step classes somehow? don't want to make remote
  // actions undoable by local user
  // TODO validation?
  switch (data.type) {
    case 'addObjects':
      console.log('adding remote objects');
      var svgDoc = (new DOMParser()).parseFromString(
	'<svg xmlns="' + svgNS + '" xmlns:xlink="' + xlinkNS + '">' +
	data.outerHTML +
	'</svg>',
	'image/svg+xml'
      );
      // FIXME order reversed
      var cs = svgDoc.documentElement.childNodes;
      for (var i = cs.length-1; i >= 0; i--) {
	doc.appendChild(document.adoptNode(cs[i]));
      }
      break;
    case 'deleteObjects':
      getElementsByIds(data.ids).map(function(e) { e.remove(); });
      break;
    case 'moveObjects':
      moveObjects(getElementsByIds(data.ids), data.movement);
      break;
    case 'sizeObjects':
      if ('size' in data) {
	getElementsByIds(data.ids).map(function(e) {
	  setObjectSize(e, data.size);
	});
      } else if ('sizes' in data) {
	getElementsByIds(data.ids).map(function(e, i) {
	  setObjectSize(e, data.sizes[i]);
	});
      } else {
	throw new Error("expected either size or sizes in sizeObjects step");
      }
      break;
    case 'colorObjects':
      if ('color' in data) {
	getElementsByIds(data.ids).map(function(e) {
	  setObjectColor(e, data.color);
	});
      } else if ('colors' in data) {
	getElementsByIds(data.ids).map(function(e, i) {
	  setObjectColor(e, data.colors[i]);
	});
      } else {
	throw new Error("expected either color or colors in colorObjects step");
      }
      break;
    default:
      console.log('unknown incoming data type: ' + data.type);
  }
}

//// selection manipulation ////

// move existing selection back to doc
function anchorSelection() {
  var cs = selection.childNodes;
  for (var i = cs.length - 1; i >= 0; i--) {
    var c = cs[i];
    selection.removeChild(c);
    doc.appendChild(c);
  }
}

function updateSelectRect() {
  selectRect.setAttribute('x', Math.min(selectRectStart.x, selectRectEnd.x));
  selectRect.setAttribute('y', Math.min(selectRectStart.y, selectRectEnd.y));
  selectRect.setAttribute('width',
    Math.abs(selectRectEnd.x - selectRectStart.x));
  selectRect.setAttribute('height',
    Math.abs(selectRectEnd.y - selectRectStart.y));
}

//// text manipulation ////

function newTextInput(pageCoords) {
  textToolInput.setAttribute('style',
    'left: ' + pageCoords.x + 'px; ' +
    'top: ' + pageCoords.y + 'px; '
  );
  setObjectSize(textToolInput);
  setObjectColor(textToolInput);
  textToolInput.focus();
  startAction();
}

function dismissTextInput() {
  // clear the input and hide it
  textToolInput.value = '';
  textToolInput.setAttribute('style', 'display: none;');
  cancelAction();
}

// convert the value of textToolInput to an SVG text node, unless it's empty,
// and then dismiss textToolInput
function finishTextInput() {
  var val = textToolInput.value;
  if (val != '') {
    // add a text element in the same place, with a tspan for each line of val
    var style = textToolInput.style;
    var pageCoords = {
      pageX: parseInt(style.getPropertyValue('left').replace(/px$/,'')),
      pageY: parseInt(style.getPropertyValue('top').replace(/px$/,'')),
    };
    docCoords = getEventCoordsRelativeToDoc(pageCoords);
    var text = document.createElementNS(svgNS, 'text');
    text.setAttribute('transform', 'translate(' + docCoords.x + ', ' + docCoords.y + ')');
    // TODO use get/set Object Size/Color here?
    var ptSize = parseFloat(style.getPropertyValue('font-size'));
    var scale = doc.transform.baseVal.getItem(1).matrix.a;
    text.setAttribute('style',
      'font-size: ' + (ptSize / scale) + 'pt; ' +
      'fill: ' + style.getPropertyValue('color') + ';'
    );
    var lines = val.split("\n");
    for (var i = 0; i < lines.length; i++) {
      var tspan = document.createElementNS(svgNS, 'tspan');
      tspan.setAttribute('x', 0);
      tspan.setAttribute('dy', '1em');
      tspan.appendChild(document.createTextNode(lines[i]));
      text.appendChild(tspan);
    }
    doc.appendChild(text);
    if (currentAction) {
      addToAction(new AddObject(text));
      finishAction();
    }
  }
  dismissTextInput();
}

function reopenTextInput(tspan) {
  var text = getDocChild(tspan);
  startAction(new DeleteObjects(text)); // step 1: delete old text
  var tspans = text.childNodes;
  var lines = [];
  for (var i = tspans.length; i >= 0; i--) {
    if (tspans[i] instanceof SVGTSpanElement) {
      lines.push(tspans[i].innerHTML);
    }
  }
  lines.reverse();
  textToolInput.value = lines.join("\n");
  var style = textToolInput.style;
  // TODO use get/set ObjectSize here?
  var ptSize = parseFloat(text.style.getPropertyValue('font-size'));
  var scale = doc.transform.baseVal.getItem(1).matrix.a;
  style.setProperty('font-size', (ptSize * scale) + 'pt');
  setObjectColor(textToolInput, getObjectColor(text));
  var translateMatrix = text.transform.baseVal.getItem(0).matrix;
  var docCoords = { x: translateMatrix.e, y: translateMatrix.f };
  var pageCoords = getDocCoordsRelativeToPage(docCoords);
  style.setProperty('left', pageCoords.x + 'px');
  style.setProperty('top', pageCoords.y + 'px');
  doc.removeChild(text);
  show(textToolInput);
  textToolInput.focus();
}

//// general document manipulation ////

// remove connections (arrows, line elements) that have one end in the selection
function removeSelectionConnections() {
  var cs = doc.childNodes;
  for (var i = cs.length-1; i >=0; i--) {
    if (cs[i] instanceof SVGLineElement) {
      var headID = cs[i].getAttribute('head-id');
      var headObject = document.getElementById(headID);
      var tailID = cs[i].getAttribute('tail-id');
      var tailObject = document.getElementById(tailID);
      if (headObject.parentNode === selection ||
	  tailObject.parentNode === selection) {
	doc.removeChild(cs[i]);
	if (currentAction && currentAction[0] instanceof DeleteObjects) {
	  currentAction[0].add(cs[i]);
	}
      }
    }
  }
}

function removeAllChildren(node) {
  var cs = node.childNodes;
  if (currentAction && currentAction[0] instanceof DeleteObjects) {
    currentAction[0].add(cs);
  }
  for (var i = cs.length-1; i >= 0; i--) {
    node.removeChild(cs[i]);
  }
}

function appendNewline(node) {
  node.appendChild(document.createTextNode("\n"));
}

function clearDocument() {
  dismissTextInput();
  removeAllChildren(doc);
  removeAllChildren(selection);
}

function panRelative(delta, draggedObject) {
  if (!draggedObject) {
    draggedObject = doc.transform.baseVal.getItem(0);
  }
  var newTranslate = {
    x: draggedObject.matrix.e + delta.x,
    y: draggedObject.matrix.f + delta.y
  };
  draggedObject.setTranslate(newTranslate.x, newTranslate.y);
}

function zoomRelative(factor, docCoords) {
  var transform = doc.transform.baseVal;
  var translate = transform.getItem(0);
  var scale = transform.getItem(1);
  var scaleVal = scale.matrix.a;
  var newScale = scaleVal * factor;
  var newTranslate = {
    x: translate.matrix.e + docCoords.x * scaleVal * (1-factor),
    y: translate.matrix.f + docCoords.y * scaleVal * (1-factor)
  };
  translate.setTranslate(newTranslate.x, newTranslate.y);
  scale.setScale(newScale, newScale);
  copyDocTransformToSelection();
  zoomFactor.innerHTML = '' + newScale + 'x';
}

function getDocChild(targ) {
  // select the child of doc that was clicked on
  var o = targ;
  while (o.parentNode != doc) {
    if (!o.parentNode) {
      throw "WTF";
    }
    o = o.parentNode;
  }
  return o;
}

// FIXME: if an arrow and only one of its connected objects is selected, only that end of the arrow should move
// FIXME 2: sometimes an object will become disconnected even though its ID still matches the arrow's head-id or tail-id; maybe related to copying?
// FIXME 3: this is now called in response to remote moves, so half-moved arrows might also be in the local selection, not just doc
function moveObjects(os, docMovement) {
  // translate each object, and consolidate its transform list
  for (var i = os.length-1; i >= 0; i--) {
    if ('transform' in os[i]) {
      var translate = svg.createSVGTransform();
      translate.setTranslate(docMovement.x, docMovement.y);
      os[i].transform.baseVal.appendItem(translate);
      os[i].transform.baseVal.consolidate();
    }
  }
  // move the heads/tails of arrows not in os attached to objects in os
  if (os === selection.childNodes) { // HACK to make this O(n) instead of O(n^2)
    var wasMoved = function(o) { return o.parentNode === selection; };
  } else {
    var wasMoved = function(o) { return os.indexOf(o) > -1; };
  }
  var cs = doc.childNodes;
  for (var i = cs.length-1; i >= 0; i--) {
    if (cs[i] instanceof SVGLineElement) { // arrow
      var headID = cs[i].getAttribute('head-id');
      var headObject = document.getElementById(headID);
      if (wasMoved(headObject)) {
	cs[i].x2.baseVal.value += docMovement.x;
	cs[i].y2.baseVal.value += docMovement.y;
      }
      var tailID = cs[i].getAttribute('tail-id');
      var tailObject = document.getElementById(tailID);
      if (wasMoved(tailObject)) {
	cs[i].x1.baseVal.value += docMovement.x;
	cs[i].y1.baseVal.value += docMovement.y;
      }
    }
  }
}

//// settings change handlers ////

function setObjectSize(o, size) {
  if (size === undefined) {
    size = currentSize;
  }
  if (o instanceof SVGPathElement ||
      o instanceof SVGLineElement) {
    o.setAttribute('stroke-width', size * 2);
  } else if (o instanceof SVGTextElement) {
    o.style.setProperty('font-size', (parseInt(size) + 7) + 'pt');
  } else if (o instanceof HTMLTextAreaElement) {
    var scale = doc.transform.baseVal.getItem(1).matrix.a;
    o.style.setProperty('font-size', ((parseInt(size) + 7) * scale) + 'pt');
  } else if (o instanceof SVGImageElement) {
    var scale = size / 5.0;
    o.transform.baseVal.getItem(0).matrix.a = scale;
    o.transform.baseVal.getItem(0).matrix.d = scale;
  }
}

function getObjectSize(o) {
  if (o instanceof SVGPathElement ||
      o instanceof SVGLineElement) {
    return o.getAttribute('stroke-width') / 2;
  } else if (o instanceof SVGTextElement) {
    return o.style.getPropertyValue('font-size').replace(/pt$/,'') - 7;
  } else if (o instanceof SVGImageElement) {
    // FIXME it's not this simple, see above
    if (o.transform.baseVal.numberOfItems == 0) {
      return 5;
    } else {
      return o.transform.baseVal.getItem(0).matrix.a * 5;
    }
  } else {
    return undefined;
  }
}

function onSizeButtonClick(button, e) {
  e.stopPropagation();
  var circle = button.childNodes[button.childNodes.length - 2];
  var size = circle.getAttribute('r');
  currentSize = size;
  console.log("current size is now " + currentSize);
  makeToolbarUnclicked(sizeToolbar);
  makeButtonClicked(button);
  // update selected objects
  var cs = selection.childNodes;
  startAction(new SizeObjects(cs, currentSize));
  currentAction[0].redo();
  finishAction();
};

function switchColor(colorButton) {
  var circle = colorButton.lastElementChild;
  var color = circle.getAttribute('fill');
  currentColor = color;
  colorInput.value = color;
  console.log("current color is now " + currentColor);
  makeToolbarUnclicked(colorToolbar);
  makeButtonClicked(colorButton);
}

function switchToNextColor(currentColorButton) {
  if (!currentColorButton) {
    // not supplied, look up by class
    currentColorButton = document.getElementsByClassName('clicked color')[0];
  }
  if (!currentColorButton) {
    // no clicked color, pick the first one and return
    switchColor(colorToolbar.childNodes[3]);
    return;
  } else {
    currentColorButton = currentColorButton.parentNode;
  }
  var nextColorButton = currentColorButton.nextSibling.nextSibling;
  if (!nextColorButton) {
    // wrap to beginning
    nextColorButton = colorToolbar.childNodes[3];
  }
  switchColor(nextColorButton);
}

function setObjectColor(o, color) {
  if (color === undefined) {
    color = currentColor;
  }
  if (o instanceof SVGPathElement ||
      o instanceof SVGLineElement) {
    o.setAttribute('stroke', color);
  } else if (o instanceof SVGTextElement) {
    o.style.setProperty('fill', color);
  } else if (o instanceof HTMLTextAreaElement) {
    o.style.setProperty('color', color);
  }
}

function getObjectColor(o) {
  if (o instanceof SVGPathElement ||
      o instanceof SVGLineElement) {
    return o.getAttribute('stroke');
  } else if (o instanceof SVGTextElement) {
    return o.style.getPropertyValue('fill');
  } else if (o instanceof HTMLTextAreaElement) {
    return o.style.setProperty('color');
  }
}

function onColorButtonClick(button, e) {
  e.stopPropagation();
  switchColor(button);
  // update selected objects
  var cs = selection.childNodes;
  startAction(new ColorObjects(cs, currentColor));
  currentAction[0].redo();
  finishAction();
}

function addColor(newColor) {
  // default to color input value
  if (!newColor) {
    newColor = colorInput.value;
  }
  // make new color button g
  var g = document.createElementNS(svgNS, 'g');
  // X coordinate of last color
  var lastColor = colorToolbar.lastElementChild;
  if (lastColor instanceof SVGGElement) {
    var x = colorToolbar.lastElementChild.transform.baseVal.getItem(0).matrix.e;
  } else {
    var x = 224; // -1st color
  }
  // ... next color
  g.setAttribute('transform', 'translate(' + (x+32) + ',0)');
  // ... and the actions toolbar
  actionsToolbar.setAttribute('transform', 'translate(' + (x+96) + ',0)');
  // child elements of g
  var use = document.createElementNS(svgNS, 'use');
  use.setAttribute('class', 'unclicked frame');
  use.setAttributeNS(xlinkNS, 'href', '#icon-frame');
  g.appendChild(use);
  var circle = document.createElementNS(svgNS, 'circle');
  circle.setAttribute('class', 'unclicked color');
  circle.setAttribute('fill', newColor); // K--------------
  circle.setAttribute('r', 10);
  circle.setAttribute('cx', 16);
  circle.setAttribute('cy', 16);
  g.appendChild(circle);
  // add g to toolbar
  colorToolbar.appendChild(g);
  appendNewline(colorToolbar);
  // set up handler
  g.onclick = onColorButtonClick.bind(this, g);
  // switch to it
  switchColor(g);
}

function removeCurrentColor() {
  // find g, remove it, move some colors and delete button left 32px
  var cs = colorToolbar.childNodes;
  for (i = cs.length-1; i >= 0; i--) {
    if (cs[i] instanceof SVGGElement) {
      if (cs[i].lastElementChild.getAttribute('class') == 'clicked color') {
	switchToNextColor();
	colorToolbar.removeChild(cs[i]);
	break;
      } else {
	// move left 32px
	cs[i].transform.baseVal.getItem(0).matrix.e -= 32;
      }
    }
  }
  actionsToolbar.transform.baseVal.getItem(0).matrix.e -= 32;
}

function changeCurrentColor(newColor) {
  console.log('changing current color from ' + currentColor + ' to ' + newColor);
  var circle = document.getElementsByClassName('clicked color')[0];
  circle.setAttribute('fill', newColor);
  currentColor = newColor;
}

// very simple attempt to generate pronounceable names
var vowels = 'aeiou'; // no y
var consonants = 'bcdfghjklmnprstvwxz'; // no q, y
function generateRandomName(inputID) {
  var name = '';
  var cv = 's';
  for (var i = Math.floor(Math.random() * 6) + 5; // 5-10 letters at random
       i > 0;
       i--) {
    // alternate consonants and vowels, starting at random
    switch (cv) {
      case 's': cv = (Math.random() < 0.5 ? 'c' : 'v'); break;
      case 'c': cv = 'v'; break;
      case 'v': cv = 'c'; break;
    }
    // add a random consonant or vowel
    var str = (cv == 'c' ? consonants : vowels);
    name += str[Math.floor(Math.random() * str.length)];
  }
  if (inputID) {
    var input = document.getElementById(inputID);
    if (/^remote-user-\d+-name$/.test(input.id)) {
      onFocusRemoteUserName(input);
      input.value = name;
      onChangeRemoteUserName(input);
    } else { // local user name
      input.value = name;
      onChangeLocal();
    }
  }
  return name;
}

function onFocusRemoteUserName(input) {
  input.oldValue = input.value;
}

function onChangeRemoteUserName(input) {
  var id = input.id.replace(/-name$/, '-uri');
  var uriInput = document.getElementById(id);
  if (isValidUserName(input.value) && isValidUserName(localUserName.value)) {
    uriInput.value = blankWhiteboardUri.value + '#' + input.value + '+' + localUserName.value;
  } else {
    uriInput.value = '';
  }
  if (collaborationHub == localUserName.value) {
    if (isValidUserName(input.value) && !isValidUserName(input.oldValue)) {
      // value became valid
      // open new peer connection
      if (!/^remote-user-(\d+)-name$/.test(input.id)) { throw new Error('WTF') }
      var i = parseInt(RegExp.lastParen);
      openPeerConnection(i, input.value);
      // notify all other users with addRemoteUser message
      broadcast({
	type: 'addRemoteUser',
	name: input.value,
	status: getUserStatus(input.value)
      }, input.value);
    } else if (isValidUserName(input.oldValue) &&
	       !isValidUserName(input.value)) {
      // value became invalid
      // close existing peer connection
      if (input.oldValue in peerConnections) {
	peerConnections[input.oldValue].close();
	delete peerConnections[input.oldValue];
      }
      // notify all other users with removeRemoteUser message
      broadcast({ type: 'removeRemoteUser', name: input.oldValue });
    } // TODO both old and new value valid: broadcast name change? really should only be able to change one's own name...
  }
  input.oldValue = input.value;
}

function onChangeLocal() {
  var input;
  for (var i = 1; input = document.getElementById('remote-user-' + i + '-name'); i++) {
    onChangeRemoteUserName(input);
  }
}

function addUserStatus(i, name, status) {
  var newLi = document.createElement('li');
  newLi.id = 'remote-user-' + i + '-status';
  newLi.className = status;
  var span = document.createElement('span');
  span.appendChild(document.createTextNode(name));
  newLi.appendChild(span);
  userStatusList.appendChild(newLi);
}

function addUser(name, status) {
  // get next remote user index
  var lastRemoteUserLi = addRemoveUserLi.previousElementSibling;
  var i = 0;
  if (lastRemoteUserLi && /^remote-user-(\d+)-li$/.test(lastRemoteUserLi.id)) {
    i = parseInt(RegExp.lastParen);
  }
  i++;
  // add to user name input list
  var newUserHTML = remoteUsers.firstElementChild.outerHTML.
    replace(/id="remote-user-1-/g, 'id="remote-user-' + i + '-').
    replace(/-1-name'\)">/g, '-' + i + "-name')\">");
  var newLi = document.createElement('li');
  remoteUsers.insertBefore(newLi, addRemoveUserLi);
  newLi.outerHTML = newUserHTML;
  var newUserNameInput = document.getElementById('remote-user-' + i + '-name');
  newUserNameInput.oldValue = '';
  newUserNameInput.value = (name ? name : '');
  if (name) {
    addUserStatus(i, name, (status || 'disconnected'));
  }
  onChangeRemoteUserName(newUserNameInput);
}

function forEachRemoteUser(fn, includeEmpty) {
  var i;
  var remoteUserNameInput;
  for (i = 1;
       (remoteUserNameInput =
	 document.getElementById('remote-user-' + i + '-name')) &&
       (includeEmpty || remoteUserNameInput.value.length > 0);
       i++) {
    if (!fn(i, remoteUserNameInput.value, remoteUserNameInput)) {
      return false;
    }
  }
  return true;
}

function indexOfRemoteUser(name) {
  var index = -1;
  forEachRemoteUser(function(i, nm) {
    if (nm == name) {
      index = i;
      return false; // break
    }
    return true;
  });
  return index;
}

function removeUser(name) {
  var i = 0;
  var remoteUserLi = undefined;
  if (name) {
    // if a name was given, find the input with that name as the value
    i = indexOfRemoteUser(name);
    if (i > -1) { // if found, get the corresponding li
      remoteUserLi = document.getElementById('remote-user-' + i + '-li');
    }
    // FIXME? if we remove a user from the middle, the indexes in the IDs and on the list item markers will become out of sync. do I care?
  } else {
    // if no name was given, get the last user name and li
    remoteUserLi = addRemoveUserLi.previousElementSibling;
    if (remoteUserLi && /^remote-user-(\d+)-li$/.test(remoteUserLi.id)) {
      i = parseInt(RegExp.lastParen);
      var remoteUserNameInput =
	document.getElementById('remote-user-' + i + '-name');
      name = remoteUserNameInput.value;
    }
  }
  if (remoteUserLi) { // found a user to remove
    // shut down the user's connection if it exists
    if (name in peerConnections) {
      peerConnections[name].close();
      delete peerConnections[name];
    }
    // remove the li
    remoteUsers.removeChild(remoteUserLi);
    // remove the user status li too
    var statusLi = document.getElementById('remote-user-' + i + '-status');
    userStatusList.removeChild(statusLi);
    // if we're the hub, tell others to remove the user as well
    if (collaborationHub == localUserName.value) {
      broadcast({ type: 'removeRemoteUser', name: name});
    }
  }
}

function setUserStatus(name, status) {
  var i = indexOfRemoteUser(name);
  var statusLi = document.getElementById('remote-user-' + i + '-status');
  statusLi.className = status;
  // if we're the hub, broadcast the status change to everyone else
  if (collaborationHub == localUserName.value) {
    broadcast({
      type: 'userStatus',
      name: name,
      status: status
    }, name);
  }
}

function getUserStatus(name) {
  var i = indexOfRemoteUser(name);
  if (i < 0) { return 'disconnected'; }
  var statusLi = document.getElementById('remote-user-' + i + '-status');
  if (!statusLi) { return 'disconnected'; }
  return statusLi.className;
}

function showCollaborationBar() {
  show(collaborationBar);
  // move bottom of svg up to make room for height of collaboration bar
  svgContainer.style.setProperty('bottom', getComputedStyle(collaborationBar).getPropertyValue('height'));
}

function hideCollaborationBar() {
  hide(collaborationBar);
  svgContainer.style.setProperty('bottom', 0);
}

function openPeerConnection(index, remoteUser) {
  var pc = new PeerConnection(remoteUser);
  pc.onopen = onPeerConnectionOpen;
  pc.onmessage = onmessage;
  pc.onclose = onPeerConnectionClose;
  pc.open();
  addUserStatus(index, remoteUser, 'disconnected');
}

function startCollaborating(hub) {
  if (collaborationHub) { // already collaborating
    return;
  }
  if (hub) { // they're the hub
    collaborationHub = hub;
    // only connect to them
    openPeerConnection(1 /* assumed */, collaborationHub);
  } else { // we're the hub
    collaborationHub = localUserName.value;
    // connect to all remote users
    var remoteUserNameInput = undefined;
    forEachRemoteUser(function(i, name) {
      openPeerConnection(i, name);
      return true;
    });
  }
  showCollaborationBar();
}

function stopCollaborating() {
  for (k in peerConnections) {
    peerConnections[k].close();
  }
  peerConnections = {};
  collaborationHub = undefined;
  hideCollaborationBar();
}

function restoreDefaultSettings() {
  // remove all color buttons
  removeAllChildren(colorToolbar);
  appendNewline(colorToolbar);
  // move actions toolbar to its minimum X coordinate
  actionsToolbar.setAttribute('transform', 'translate(288,0)');
  // add back tooltip
  var colorTooltip = document.createElementNS(svgNS, 'title');
  colorTooltip.innerHTML = 'set pen color';
  colorToolbar.appendChild(colorTooltip);
  appendNewline(colorToolbar);
  // add back default colors
  addColor('#c00000');
  addColor('#c0c000');
  addColor('#00c000');
  addColor('#00c0c0');
  addColor('#0000c0');
  addColor('#c000c0');
  addColor('#000000');
  // switch to default color
  switchColor(colorToolbar.childNodes[11]); // blue
  panScrollX.value = 53;
  panScrollY.value = 53;
  invertScrollZoom.checked = false;
  zoomStep.value = 2;
  // fisheye settings
  enableFisheye.checked = true;
  fisheyeBorderSquash.value = 3;
  fisheyeBorderThickness.value = 15;
  fisheyeTimeout.value = 250;
  signalingRelayUri.value = "https://ssl.uofr.net/~willdb/cgi-bin/relay.pl";
  iceServers.value =
    "[\n" +
    "{\"urls\":\"stun:stun.ekiga.net\"},\n" +
    "{\"urls\":\"stun:stun.iptel.org\"},\n" +
    "{\"urls\":\"stun:stun.l.google.com:19302\"},\n" +
    "{\"urls\":\"stun:stun1.l.google.com:19302\"},\n" +
    "{\"urls\":\"stun:stun2.l.google.com:19302\"},\n" +
    "{\"urls\":\"stun:stun3.l.google.com:19302\"},\n" +
    "{\"urls\":\"stun:stun4.l.google.com:19302\"},\n" +
    "{\n" +
    "        \"urls\": \"turn:numb.viagenie.ca\",\n" +
    "        \"credential\": \"muazkh\",\n" +
    "        \"username\": \"webrtc@live.com\"\n" +
    "}\n" +
    "]";
  enableSignalingFallback.checked = false;
}

function updateFisheye() {
  var pageDims = svg.getBoundingClientRect();
  var thickness = fisheyeBorderThickness.value / 100.0;
  var xThickness = Math.round(pageDims.width * thickness);
  var yThickness = Math.round(pageDims.height * thickness);
  var clipRectXs = [0, xThickness, pageDims.width - xThickness, pageDims.width];
  var clipRectYs = [0, yThickness, pageDims.height - yThickness, pageDims.height];
  var scale = 1.0 / fisheyeBorderSquash.value;
  var scales = [scale, 1, scale];
  var translateXs = [xThickness * (1-scale), 0, clipRectXs[2] * (1-scale)];
  var translateYs = [yThickness * (1-scale), 0, clipRectYs[2] * (1-scale)];
  for (var y = 0; y < 3; y++) {
    for (var x = 0; x < 3; x++) {
      if (x == 1 && y == 1) {
	continue;
      }
      var suffix = '-' + x + y;
      var clipRect = document.getElementById('fecp' + suffix).firstElementChild;
      clipRect.setAttribute('x', clipRectXs[x]);
      clipRect.setAttribute('y', clipRectYs[y]);
      clipRect.setAttribute('width', clipRectXs[x+1] - clipRectXs[x]);
      clipRect.setAttribute('height', clipRectYs[y+1] - clipRectYs[y]);
      var use = document.getElementById('feu' + suffix);
      use.setAttribute('transform', 'translate(' + translateXs[x] + ',' + translateYs[y] + ') scale(' + scales[x] + ',' + scales[y] + ')');
    }
  }
  fisheyeShadow.setAttribute('stroke-width', thickness * 2 * (fisheyeBorderSquash.value - 1) * scale);
  fisheyeShadow.setAttribute('transform', 'scale(' + pageDims.width + ',' + pageDims.height + ')');
}

//// import ////
// TODO handle more errors

function importImageFile(file, pageCoords, onImageError) {
  var reader = new FileReader();
  reader.onload = function(e) {
    var uri = e.target.result;
    var imageElement = document.createElementNS(svgNS, 'image');
    // also need to load the image into an Image to get its natural
    // dimensions
    var imageObject = new Image();
    imageObject.onerror = onImageError;
    imageObject.onload = function() {
      anchorSelection();
      if (!pageCoords) {
	// center the image in the current view
	var pageDims = svg.getBoundingClientRect();
	pageCoords = {
	  pageX: pageDims.width / 2,
	  pageY: pageDims.height / 2
	};
      }
      var docCoords = getEventCoordsRelativeToDoc(pageCoords);
      // put the center of the image at the origin of its local coordinate
      // system
      imageElement.setAttribute('x', -imageObject.naturalWidth / 2);
      imageElement.setAttribute('y', -imageObject.naturalHeight / 2);
      // translate it to the desired coordinates
      imageElement.setAttribute('transform', 'translate(' + docCoords.x + ',' + docCoords.y + ') scale(1)');
      imageElement.setAttribute('width', imageObject.naturalWidth);
      imageElement.setAttribute('height', imageObject.naturalHeight);
      imageElement.setAttributeNS(xlinkNS, 'href', uri);
      doc.appendChild(imageElement);
      imageElement.transform.baseVal.consolidate();
      setObjectSize(imageElement);
      startAction(new AddObject(imageElement));
      finishAction();
      console.log("finished importing image file " + file.name);
    };
    imageObject.src = uri;
  };
  reader.readAsDataURL(file);
}

function importTextString(string, pageCoords) {
  if (!isHidden(textToolInput)) {
    finishTextInput();
  }
  newTextInput(pageCoords);
  textToolInput.value = string;
  finishTextInput();
}

function importTextFile(file, pageCoords) {
  var reader = new FileReader();
  reader.onload = function(e) {
    var text = e.target.result;
    if (!pageCoords) {
      var pageDims = svg.getBoundingClientRect();
      var pageCenter = { x: pageDims.width / 2, y: pageDims.height / 2 };
      // TODO try to measure the width and height of the text and center it
      pageCoords = pageCenter;
    }
    importTextString(text, pageCoords);
    console.log("finished importing text file " + file.name);
  };
  reader.readAsText(file);
}

function importFile(file, pageCoords) {
  console.log("importing file " + file.name + "; type is " + file.type);
  if (file.type == 'text/plain') {
    importTextFile(file, pageCoords);
  } else if (file.type == '') {
    // try importing as image, failing that, as text
    importImageFile(file, pageCoords, function() {
      console.log("failed to import file " + file.name + " as image; trying text");
      importTextFile(file, pageCoords);
    });
  } else if (/^image\//.test(file.type)) {
    importImageFile(file, pageCoords, function(e) { alert("Error importing image"); });
  } else {
    alert("Error: imported file is of non-image, non-plaintext type: " + file.type);
  }
}

//// SignalingRelay ////

function isValidUserName(n) {
  return /^[\w-]+$/.test(n);
}

function ensureValidUserName(n) {
  if (!isValidUserName(n)) {
    var msg = "Invalid user name: " + n + "\nUser names should contain only letters, numbers, hyphens, and underscores.";
    alert(msg);
    throw new Error(msg);
  }
  return n;
}

function SignalingRelay(url, localUser, remoteUser) {
  this.url = url;
  this.localUser = ensureValidUserName(localUser);
  this.remoteUser = ensureValidUserName(remoteUser);
  this.writeBuffer = [];
  this.isOpen = true;
  this.receive();
}

defineMethods(SignalingRelay, [

  function receive() {
    console.log('listening to ' + this.remoteUser + ' via signaling relay');
    var that = this;
    this.receiveXHR = new XMLHttpRequest();
    this.receiveXHR.onload = function() {
      try {
	var text = that.receiveXHR.responseText;
	console.log('received from ' + that.remoteUser + ' via signaling relay: ' + text);
	that.ondata(JSON.parse(text));
      } catch (err) {
	console.log(err.stack);
      }
      if (that.isOpen) {
	that.receive();
      }
    };
    this.receiveXHR.onerror = function(e) {
      console.log(e);
    };
    this.receiveXHR.open('POST', this.url, true);
    this.receiveXHR.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
    this.receiveXHR.send('k=' + this.remoteUser + '-' + this.localUser);
  },

  function sendBufferedMessages() {
    if (this.writeBuffer.length > 0) {
      var text = this.writeBuffer[0];
      var xhr = new XMLHttpRequest();
      // once we've sent this message, remove it from the buffer, and recurse
      // to send the rest of them
      var that = this;
      xhr.onload = function() {
	that.writeBuffer.shift();
        that.sendBufferedMessages();
      };
      xhr.onerror = function(e) { console.log(e); };
      console.log('sending to ' + this.remoteUser + ' via signaling relay: ' + text);
      xhr.open('POST', this.url, true);
      xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
      xhr.send(
	'k=' + this.localUser + '-' + this.remoteUser +
	'&m=' + encodeURIComponent(text)
      );
    }
  },

  function write(data) {
    var text = JSON.stringify(data);
    this.writeBuffer.push(text);
    // if we just pushed the only entry in the buffer, start
    // sendBufferedMessages
    if (this.writeBuffer.length == 1) {
      this.sendBufferedMessages();
    }
  },

  function close() {
    this.isOpen = false;
    this.receiveXHR.abort();
  }

]);

//// PeerConnection ////

RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection;
RTCSessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription;
RTCIceCandidate = window.RTCIceCandidate || window.mozRTCIceCandidate;

function PeerConnection(remoteUser) {
  this.remoteUser = remoteUser;
  this.localUser = localUserName.value;
  // if we're alphabetically first, we're the one to create the data channel
  this.shouldCreateChannel =
    (this.remoteUser.localeCompare(this.localUser, 'en') > 0);
  this.iceServers = JSON.parse(iceServers.value);
  this.isOpen = false;
  this.fellBack = false;
  peerConnections[remoteUser] = this;
}

defineMethods(PeerConnection, [

  function open() {
    this.relay = new SignalingRelay(
      signalingRelayUri.value, this.localUser, this.remoteUser);
    this.relay.ondata = this.onRelayData.bind(this);
    this.relay.write({ handshake: true });
  },

  function send(msg) {
    if (this.fellBack) {
      this.relay.write(msg);
    } else {
      msg = JSON.stringify(msg);
      console.log('sending to ' + this.remoteUser + ' via data channel: ' + msg);
      this.dataChannel.send(msg);
    }
  },

  function close() {
    this.isOpen = false;
    if (this.relay) {
      this.relay.close();
      delete this.relay;
    }
    if (this.rtcpc) {
      this.rtcpc.close();
      delete this.rtcpc;
    }
    if (this.dataChannel) {
      this.dataChannel.close();
      delete this.dataChannel;
    }
  },

  function logError(e) {
    //console.log(e.name + ': ' + e.message);
    console.log(e);
  },

  function onRelayData(data) {
    if (this.fellBack) {
      // TODO try-catch?
      this.onmessage(data);
      this.rebroadcastIfHub(data);
    } else if (data.fellBack) {
      this.fellBack = true;
    } else if (data.handshake || !this.rtcpc) {
      this.onHandshake();
    } else if (data.desc) {
      var desc = data.desc;
      switch (desc.type) {
	case 'offer':
	  var that = this;
	  /* how the spec does it, vs. Chrome's legacy interface
	  this.rtcpc.setRemoteDescription(new RTCSessionDescription(desc)).
	  then(function() {
	    console.log('setRemoteDescription then');
	    return that.rtcpc.createAnswer();
	  }).then(function(answer) {
	    console.log('setRemoteDescription then then');
	    return that.rtcpc.setLocalDescription(answer);
	  }).then(function() {
	    console.log('setRemoteDescription then then then');
	    that.relay.write({ desc: that.rtcpc.localDescription });
	  }).catch(this.logError.bind(this));
	   */
	  this.rtcpc.setRemoteDescription(new RTCSessionDescription(desc), function() {
	    console.log('setRemoteDescription success');
	    that.rtcpc.createAnswer(function(answer) {
	      console.log('createAnswer success');
	      that.rtcpc.setLocalDescription(answer, function() {
		console.log('setLocalDescription success');
		that.relay.write({ desc: that.rtcpc.localDescription });
	      }, that.logError.bind(that));
	    }, that.logError.bind(that));
	  }, this.logError.bind(this));
	  break;
	case 'answer':
	  this.rtcpc.setRemoteDescription(new RTCSessionDescription(desc)
	  /* ).catch( */ , function() {}, // spec vs. legacy
	  this.logError.bind(this));
	  break;
	default:
	  log("Unsupported SDP type.");
      }
    } else {
      this.rtcpc.addIceCandidate(new RTCIceCandidate(data.candidate)
      /* ).catch( */ , function() {}, // spec vs. legacy
      this.logError.bind(this));
    }
  },

  function onHandshake() {
    this.rtcpc = new RTCPeerConnection({ iceServers: this.iceServers });
    this.rtcpc.onicecandidate = this.onicecandidate.bind(this);
    this.rtcpc.onnegotiationneeded = this.onnegotiationneeded.bind(this);
    this.rtcpc.ondatachannel = this.ondatachannel.bind(this);
    this.rtcpc.onconnectionstatechange =
      this.oniceconnectionstatechange.bind(this);
    if (this.shouldCreateChannel) {
      this.dataChannel = this.rtcpc.createDataChannel(this.remoteUser);
      this.dataChannel.onopen =
        this.onDataChannelOpen.bind(this);
    }
  },

  function oniceconnectionstatechange(e) {
    if (this.rtcpc.iceConnectionState == 'failure') {
      this.onFailure();
    }
  },

  function onFailure() {
    if (enableSignalingFallback.checked) {
      this.fellBack = true;
      this.relay.write({ fellBack: true });
    }
  },

  function onicecandidate(e) {
    console.log('onicecandidate');
    if (e.candidate) {
      if (this.relay) {
        this.relay.write({ candidate: e.candidate });
      } else {
	console.log('no relay (anymore?)');
      }
    } else {
      console.log('null candidate');
    }
  },

  function onnegotiationneeded(e) {
    console.log('onnegotiationneeded');
    var that = this;
    /* This is how the WebRTC spec and Firefox do it, but Chrome only allows
     * the "legacy" interface, so we use that instead.
    this.rtcpc.createOffer().then(function(offer) {
      console.log('createOffer then');
      return that.rtcpc.setLocalDescription(offer);
    }).then(function() {
      console.log('createOffer then then');
      that.relay.write({ desc: that.rtcpc.localDescription });
    }).catch(this.logError.bind(this));
     */
    this.rtcpc.createOffer(function(offer) {
      console.log('createOffer success');
      that.rtcpc.setLocalDescription(offer, function() {
	console.log('setLocalDescription success');
	that.relay.write({ desc: that.rtcpc.localDescription });
      }, that.logError.bind(that));
    }, this.logError.bind(this));
  },

  function ondatachannel(e) {
    console.log('got data channel from ' + this.remoteUser);
    this.dataChannel = e.channel;
    this.dataChannel.onopen = this.onDataChannelOpen.bind(this);
  },

  function onDataChannelOpen(e) {
    console.log('connected to ' + this.remoteUser);
    this.relay.close();
    delete this.relay;
    this.dataChannel.onmessage = this.onDataChannelMessage.bind(this);
    var that = this;
    this.dataChannel.onclose = function() {
      that.isOpen = false;
      that.onclose();
    };
    this.isOpen = true;
    this.onopen();
  },

  function onDataChannelMessage(e) {
    var data = e.data.toString();
    console.log('received from ' + this.remoteUser + ' via data channel: ' + data);
    try {
      console.log('attempting to parse...');
      data = JSON.parse(data);
      console.log('parsed as: ' + JSON.stringify(data));
      this.onmessage(data);
      this.rebroadcastIfHub(data);
    } catch (err) {
      this.logError(err);
    }
  },

  function rebroadcastIfHub(data) {
    if (collaborationHub == this.localUser) { // if we're the hub
      // rebroadcast the message to everyone except the user we got it from
      broadcast(data, this.remoteUser);
    }
  }

]);

function broadcast(msg, exceptUser) {
  for (var remoteUser in peerConnections) {
    if (remoteUser != exceptUser && peerConnections[remoteUser].isOpen) {
      peerConnections[remoteUser].send(msg);
    }
  }
}

//// tools ////

// event handlers for each tool
// (except onwheel, which is mostly the same for all tools)
var tools = {
  draw: {
    onmousedown: function(e, docCoords) {
      draggedObject = document.createElementNS(svgNS, 'path');
      draggedObject.setAttribute('d', 'M ' + docCoords.x + ' ' + docCoords.y);
      draggedObject.setAttribute('stroke', currentColor);
      setObjectSize(draggedObject);
      selection.appendChild(draggedObject);
      deferredMovement = { x: 0, y: 0 };
      startAction(new AddObject(draggedObject));
    },
    onmousemove: function(e, currentMovement) {
      var zoomMatrix = doc.transform.animVal.getItem(1).matrix;
      currentMovement = currentMovement.matrixTransform(zoomMatrix.inverse());
      deferredMovement = {
	x: deferredMovement.x + currentMovement.x,
	y: deferredMovement.y + currentMovement.y
      };
      if ( Math.abs(deferredMovement.x) > currentSize ||
	   Math.abs(deferredMovement.y) > currentSize
	 ) {
	var d = draggedObject.getAttribute('d');
	if (!dragging) {
	  d += ' l'; // relative lineto
	  dragging = true;
	}
	d += ' ' + deferredMovement.x + ' ' + deferredMovement.y;
	deferredMovement = { x: 0, y: 0 };
	draggedObject.setAttribute('d', d);
      }
    },
    onmouseup: function(e) {
      selection.removeChild(draggedObject);
      if (dragging) {
	doc.appendChild(draggedObject);
	if (deferredMovement.x != 0 || deferredMovement.y != 0) {
	  // do the last little bit of deferred movement
	  var d = draggedObject.getAttribute('d');
	  d += ' l ' + deferredMovement.x + ' ' + deferredMovement.y;
	  draggedObject.setAttribute('d', d);
	}
	finishAction();
      } else {
	cancelAction();
      }
      dragging = false;
      deferredMovement = null;
    }
  },
  connect: {
    ondocmousedown: function(e, docCoords) {
      anchorSelection(); // get rid of old selection
      var target = getDocChild(e.target);
      if (target instanceof SVGLineElement) { // no arrows from other arrows
	return;
      }
      var tailID = ensureID(target);
      draggedObject = document.createElementNS(svgNS, 'line'); // arrow
      // position
      draggedObject.setAttribute('x1', docCoords.x);
      draggedObject.setAttribute('y1', docCoords.y);
      draggedObject.setAttribute('x2', docCoords.x);
      draggedObject.setAttribute('y2', docCoords.y);
      // style
      draggedObject.setAttribute('stroke', currentColor);
      setObjectSize(draggedObject);
      // bookkeeping
      draggedObject.setAttribute('tail-id', tailID);
      // put arrow in selection
      selection.appendChild(draggedObject);
      // put selection below rest of document, so that mouseup goes to the
      // intended target instead of the arrow head
      // (tried using CSS z-index, didn't work)
      var selectionFilter = selection.parentNode;
      docAndSelection.removeChild(selectionFilter);
      docAndSelection.insertBefore(selectionFilter, doc);
      // change cursor so hotspot is at head
      iconToCursor('connect-dragging-icon', function(style) { svg.setAttribute('style', style); });
      startAction(new AddObject(draggedObject));
    },
    onmousemove: function(e, currentMovement) {
      draggedObject.x2.baseVal.value += currentMovement.x;
      draggedObject.y2.baseVal.value += currentMovement.y;
    },
    onmouseup: function(e) {
      if (mouseIsOverUI || // arrow to buttons
	  e.target === doc || // arrow to nowhere
	  e.target instanceof SVGLineElement || // arrow to another arrow, self
	  // circular arrow
	  e.target.id == draggedObject.getAttribute('tail-id')) {
	// cancel arrow
	selection.removeChild(draggedObject);
	cancelAction();
      } else { // arrow to another object in the document
	// complete arrow
	var headID = ensureID(getDocChild(e.target));
	draggedObject.setAttribute('head-id', headID);
	anchorSelection();
	finishAction();
      }
      // undo putting selection below rest of document (see mousedown)
      var selectionFilter = selection.parentNode;
      docAndSelection.removeChild(selectionFilter);
      docAndSelection.appendChild(selectionFilter);
      // change cursor back so hotspot is at tail
      iconToCursor('connect-icon', function(style) { svg.setAttribute('style', style); });
    }
  },
  move: {
    onmousedown: function(e, docCoords) {
      draggedObject = doc.transform.baseVal.getItem(0);
      if (enableFisheye.checked) {
	updateFisheye();
	show(fisheyeBorders);
      }
    },
    onmousemove: function(e, currentMovement) {
      panRelative(currentMovement, draggedObject);
      if (enableFisheye.checked) { // FIXME firefox workaround
	svg.removeChild(fisheyeBorders);
	svg.insertBefore(fisheyeBorders, document.getElementById('ui'));
      }
    },
    onmouseup: function(e) {
      hide(fisheyeBorders);
    }
  },
  select: {
    onmousedown: function(e, docCoords) {
      anchorSelection();
      selectRectStart = { x: e.pageX, y: e.pageY };
      selectRectEnd = { x: e.pageX, y: e.pageY };
      // set coordinates of selectRect and make it visible
      updateSelectRect();
      show(selectRect);
      draggedObject = selectRect;
    },
    ondocmousedown: function(e) {
      anchorSelection(); // get rid of old selection
      var o = getDocChild(e.target);
      doc.removeChild(o);
      selection.appendChild(o);
      draggedObject = selection;
      startAction(new MoveObjects(selection.childNodes));
    },
    onselectionmousedown: function(e) {
      draggedObject = selection;
      startAction(new MoveObjects(selection.childNodes));
    },
    onmousemove: function(e, pageMovement) {
      if (draggedObject === selectRect) {
	selectRectEnd.x += pageMovement.x;
	selectRectEnd.y += pageMovement.y;
	updateSelectRect();
      } else { // dragging selected objects
	var docMovement = getPageMovementRelativeToDoc(pageMovement);
        moveObjects(selection.childNodes, docMovement);
	currentAction[0].add(docMovement);
      }
    },
    onmouseup: function(e) {
      if (draggedObject === selectRect) {
	var enclosed = getBBEnclosureList(draggedObject.getBBox(), doc);
	for (var i = 0; i < enclosed.length; i++) {
	  doc.removeChild(enclosed[i]);
	  selection.appendChild(enclosed[i]);
	}
	hide(selectRect);
	selectRectStart = undefined;
	selectRectEnd = undefined;
      } else if (currentAction[0].nonzero()) { // dragged selected objects
        finishAction();
      } else { // just clicked, no drag
	cancelAction();
      }
    }
  },
  copy: {
    ondocmousedown: function(e) {
      anchorSelection();
      var o = getDocChild(e.target);
      var copy = o.cloneNode(true);
      selection.appendChild(copy);
      draggedObject = selection;
      startAction(new AddObject(copy));
    },
    onselectionmousedown: function(e) {
      // clone nodes under original selection, anchor it, add clones to
      // selection, and drag that
      var cs = selection.childNodes;
      var clones = [];
      startAction();
      for (var i = 0; i < cs.length; i++) {
	if ('cloneNode' in cs[i]) {
	  var clone = cs[i].cloneNode(true);
	  clones.push(clone);
	  addToAction(new AddObject(clone));
	}
      }
      anchorSelection();
      var idmap = {};
      for (var i = 0; i < clones.length; i++) {
	if (clones[i].hasAttribute('id')) { // don't clone IDs
	  var oldID = clones[i].id;
	  clones[i].removeAttribute('id');
	  var newID = ensureID(clones[i]);
	  idmap[oldID] = newID;
	}
	selection.appendChild(clones[i]);
      }
      // if we copied any arrows, map their head/tail IDs
      for (var i = 0; i < clones.length; i++) {
	if (clones[i] instanceof SVGLineElement) {
	  var oldHeadID = clones[i].getAttribute('head-id');
	  var oldTailID = clones[i].getAttribute('tail-id');
	  if (oldHeadID in idmap) {
	    clones[i].setAttribute('head-id', idmap[oldHeadID]);
	  }
	  if (oldTailID in idmap) {
	    clones[i].setAttribute('tail-id', idmap[oldTailID]);
	  }
	}
      }
      draggedObject = selection;
    },
    onmousemove: function(e, pageMovement) {
      moveObjects(selection.childNodes,
          getPageMovementRelativeToDoc(pageMovement));
    },
    onmouseup: function(e) {
      finishAction();
    }
  },
  'zoom-in': {
    onclick: function(e, docCoords) {
      zoomRelative(zoomStep.value, docCoords);
    }
  },
  'zoom-out': {
    onclick: function(e, docCoords) {
      zoomRelative(1.0 / zoomStep.value, docCoords);
    }
  },
  text: {
    onclick: function(e, docCoords) {
      if (e.target instanceof SVGTSpanElement) { // clicked on a previous text
	if (!isHidden(textToolInput)) { // finish the current one if needed
	  finishTextInput();
	}
	reopenTextInput(e.target);
      } else { // click was not on a previous text
	if (isHidden(textToolInput)) { // no active text input
	  newTextInput({ x: e.pageX, y: e.pageY });
	} else { // active text input
	  finishTextInput();
	}
      }
    }
  }
};

//// non-tool-specific event handlers ////

function onMouseDownOrClick(handlerName, e) {
  if (!mouseIsOverUI) {
    var fn = tools[currentTool][handlerName];
    if (fn) {
      var docCoords = getEventCoordsRelativeToDoc(e);
      e.stopPropagation();
      fn(e, docCoords);
    }
  }
}

function prefixProperty(pre, prop) {
  return pre + prop.replace(/^[a-z]/, function(l) { return l.toUpperCase(); });
}

function tryPrefixes(obj, prop) {
  if (prop in obj) {
    return obj[prop];
  } else if (prefixProperty('moz', prop) in obj) {
    return obj[prefixProperty('moz', prop)];
  } else if (prefixProperty('webkit', prop) in obj) {
    return obj[prefixProperty('webkit', prop)];
  } else {
    return undefined;
  }
}

// TODO consider only enabling this while the mouse button is down, to be more efficient
function onmousemove(e) {
  if (draggedObject != null) {
    var fn = tools[currentTool].onmousemove;
    if (!fn) {
      throw new Error('no mousemove handler while dragging object ' + draggedObject);
    }
    e.stopPropagation();
    var currentMovement = svg.createSVGPoint();
    currentMovement.x = tryPrefixes(e, 'movementX');
    currentMovement.y = tryPrefixes(e, 'movementY');
    fn(e, currentMovement);
    // make sure doc and selection are in sync
    copyDocTransformToSelection();
  }
}

function onmouseup(e) {
  if (draggedObject != null) {
    e.stopPropagation();
    var fn = tools[currentTool].onmouseup;
    if (fn) { fn(e); }
    draggedObject = null;
  }
}

var fisheyeTimeoutID = undefined;
function onwheel(e) {
  e.stopPropagation(e);
  var docCoords = getEventCoordsRelativeToDoc(e);
  var delta = { x: e.deltaX, y: e.deltaY }; // TODO use Z to zoom? I don't have a device that makes Z != 0
  switch (e.deltaMode) {
    case WheelEvent.DOM_DELTA_PIXEL: // Chrome
      // lean back and accept Chrome's crazy scroll unit of 53, because maybe
      // the user is using a device that isn't chunky
      break;
    case WheelEvent.DOM_DELTA_LINE: // Firefox
      // convert FF's 3-line scrolling to Chrome's 53-pixel scrolling
      delta.y = delta.y * 53.0 / 3;
      // FF only does 1-"line" horizontal scrolling
      delta.x *= 53;
      break;
    case WheelEvent.DOM_DELTA_PAGE: // ???
      // make an attempt to interpret this literally
      var pageDims = svg.getBoundingClientRect();
      delta.x *= pageDims.width;
      delta.y *= pageDims.height;
      break;
  }
  //console.log(delta.x + ' ' + delta.y);
  if (/^zoom-/.test(currentTool)) {
    var factor =
      Math.pow(zoomStep.value, (invertScrollZoom.checked ? 1 : -1) * delta.y / 53)
    zoomRelative(factor, docCoords);
  } else {
    delta.x = delta.x * panScrollX.value / 53;
    delta.y = delta.y * panScrollY.value / 53;
    panRelative(delta);
    if (enableFisheye.checked) {
      updateFisheye();
      if (enableFisheye.checked) { // FIXME firefox workaround
	svg.removeChild(fisheyeBorders);
	svg.insertBefore(fisheyeBorders, document.getElementById('ui'));
      }
      show(fisheyeBorders);
      if (fisheyeTimeoutID) {
	clearTimeout(fisheyeTimeoutID);
      }
      fisheyeTimeoutID =
        setTimeout(hide.bind(window, fisheyeBorders), fisheyeTimeout.value);
    }
  }
  copyDocTransformToSelection();
}

function onkeydown(e) {
  if (isHidden(textToolInput)) { // let keyboard shortcuts work normally for textToolInput when it's shown
    if (e.ctrlKey && e.keyCode == 90) { // ^Z = undo
      undoAction();
    } else if (e.ctrlKey && e.keyCode == 89) { // ^Y = redo
      redoAction();
    } // TODO more keyboard shortcuts
  }
}

function typeIsImportable(type) {
  return (type == '' ||
	  /^text\/plain$/.test(type) ||
	  /^image\//.test(type));
}

function ondrop(e) {
  console.log('ondrop');
  e.stopPropagation();
  e.preventDefault();
  var pageCoords = { x: e.pageX, y: e.pageY };
  var dt = e.dataTransfer;
  if ('items' in dt) { // chrome, "standard"
    for (var i = 0; i < dt.items.length; i++) {
      var item = dt.items[i];
      // accept only text/plain, image/*, and unknown type
      if (!typeIsImportable(item.type)) {
	console.log('skipping drop data item of type ' + item.type);
	continue;
      }
      switch (item.kind) {
	case 'string':
	  item.getAsString(function(string) {
	    importTextString(string, pageCoords);
	  });
	  break;
	case 'file':
	  importFile(item.getAsFile(), e);
	  break;
	default:
	  alert('unknown kind of data transfer item: ' + item.kind);
      }
    }
  } else if ('mozItemCount' in dt) { // firefox
    for (var i = 0; i < dt.mozItemCount; i++) {
      //console.log('moz item ' + i);
      var types = dt.mozTypesAt(i);
      for (var j = 0; j < types.length; j++) {
	/*console.log('  type ' + j + ' = ' + types[j]);
	try {
	  var data = dt.mozGetDataAt(types[j], i);
	  console.log('    typeof data = ' + (typeof data));
	  if (typeof data == 'object') {
	    console.log('      constructor ' + data.constructor);
	  }
	} catch (ex) {}*/
	if (types[j] == 'text/plain') {
	  importTextString(dt.mozGetDataAt('text/plain', i), pageCoords);
	  break;
	} /* else {} firefox doesn't really support dropping image data */
      }
      //console.log('  text/html = ' + dt.mozGetDataAt('text/html', i));
    }
  } else { // fall back on getData('text/plain')
    importTextString(dt.getData('text/plain'), pageCoords);
  }
}

function onPeerConnectionOpen() {
  // send all objects in our document
  // first anchor selection down to doc
  anchorSelection();
  // then make sure all doc children have IDs
  var cs = doc.childNodes;
  for (var i = cs.length-1; i >= 0; i--) {
    if (cs[i] instanceof Element) {
      ensureID(cs[i]);
    }
  }
  // then send doc's innerHTML
  this.send({ type: 'addObjects', outerHTML: doc.innerHTML });
  // send list of other users if we're the hub
  if (collaborationHub == this.localUser) {
    var that = this;
    forEachRemoteUser(function(i, name) {
      if (name != that.remoteUser) {
	that.send({
	  type: 'addRemoteUser',
	  name: name,
	  status: getUserStatus(name)
	});
      }
      return true;
    });
  }
  setIdleTimeout(this);
}

function setIdleTimeout(pc) {
  setUserStatus(pc.remoteUser, 'active');
  if (pc.idleTimeout) {
    clearTimeout(pc.idleTimeout);
  }
  pc.idleTimeout = setTimeout(onPeerConnectionIdle.bind(pc), 60000); // 1m
}

function onPeerConnectionIdle() {
  setUserStatus(this.remoteUser, 'inactive');
  this.idleTimeout = undefined;
}

function onPeerConnectionClose() {
  if (collaborationHub == this.localUser) {
    setUserStatus(this.remoteUser, 'disconnected');
  } else { // we're not the hub, we must've disconnected from the hub
    forEachRemoteUser(function(i, name) {
      setUserStatus(name, 'disconnected');
      return true;
    });
  }
  if (this.idleTimeout) {
    clearTimeout(this.idleTimeout);
  }
}

function addToTextChatHistory(sender, message) {
  var time = (new Date()).toLocaleTimeString(undefined,
    { hour: '2-digit', minute: '2-digit', second: '2-digit' });
  textChatHistory.appendChild(document.createTextNode(time + ' '));
  var b = document.createElement('b');
  // TODO assign colors to users?
  if (/^\/me /.test(message)) {
    b.appendChild(document.createTextNode('* ' + sender));
    message = RegExp.rightContext;
  } else {
    b.appendChild(document.createTextNode('<' + sender + '>'));
  }
  textChatHistory.appendChild(b);
  textChatHistory.appendChild(document.createTextNode(' ' + message));
  textChatHistory.appendChild(document.createElement('br'));
  // scroll to bottom
  textChatHistory.scrollTop = textChatHistory.scrollHeight;
}

function onmessage(data) {
  setIdleTimeout(this);
  console.log('data.type = ' + data.type);
  switch (data.type) {
    case 'chat':
      addToTextChatHistory(data.sender, data.message);
      break;
    case 'addRemoteUser':
      addUser(data.name, data.status);
      break;
    case 'removeRemoteUser':
      removeUser(data.name);
      break;
    case 'userStatus':
      setUserStatus(data.name, data.status);
      break;
    default:
      receiveStep(data);
  }
}

function onTextChatInputKeyUp(e) {
  if (e.keyCode == 13) {
    e.preventDefault();
    broadcast({
      type: 'chat',
      sender: localUserName.value,
      message: textChatInput.value
    });
    addToTextChatHistory(localUserName.value, textChatInput.value);
    textChatInput.value = '';
  }
}

//// initializiation ////

function toggleMenu() {
  toggleButtonClickedness(menuButton);
  toggleDisplay(menu);
  mouseIsOverUI = false;
}

window.onload = function() {
  svg = document.getElementsByTagName("svg")[0];
  iconStyle = document.getElementById('icon-style').outerHTML;
  var idVars = 'docAndSelection doc selection selectRect zoomFactor textToolInput helpWindow settingsWindow colorInput panScrollX panScrollY invertScrollZoom zoomStep enableFisheye fisheyeSettings fisheyeBorderSquash fisheyeBorderThickness fisheyeTimeout fisheyeBorders fisheyeShadow localUserName blankWhiteboardUri remoteUsers addRemoveUserLi signalingRelayUri iceServers enableSignalingFallback sizeToolbar colorToolbar actionsToolbar deleteButton undoButton redoButton menu menuButton collaborationBar svgContainer textChatHistory textChatInput userStatusList collaborateWindow'.split(' ')
  for (var i = idVars.length-1; i >= 0; i--) {
    var id = idVars[i].replace(/[A-Z]/g, function(m) { return '-' + m.toLowerCase(); });
    window[idVars[i]] = document.getElementById(id);
  }
  hide(menu);
  menuButton.onclick = function(e) {
    e.stopPropagation();
    toggleMenu();
    mouseIsOverUI = true;
  };
  var newButton = document.getElementById("new-button");
  newButton.onclick = function(e) {
    e.stopPropagation();
    toggleMenu();
    clearDocument();
  };
  var openButton = document.getElementById("open-button");
  var fileInput = document.getElementById("file-input");
  openButton.onclick = function(e) {
    e.stopPropagation();
    toggleMenu();
    fileInput.click();
  };
  var fileOutput = document.getElementById("file-output");
  // FIXME how to let the user load the same file twice in a row?
  fileInput.onchange = function(e) {
    clearDocument();
    var file = fileInput.files[0];
    console.log("opening file " + file.name);
    // keep the filename we opened as the one to save back to
    fileOutput.download = file.name;
    var reader = new FileReader();
    reader.onload = function(e) {
      // make a new Document from the file contents
      var parser = new DOMParser();
      var newDocument = parser.parseFromString(e.target.result, 'text/html');
      // replace our doc-and-selection with the one from the file
      var newDocAndSelection = newDocument.getElementById("doc-and-selection");
      if (!newDocAndSelection) {
	alert("failed to open file; missing doc-and-selection element");
	console.log(newDocument);
	return;
      }
      docAndSelection.outerHTML = newDocAndSelection.outerHTML;
      // redo our global vars pointing into that part of the document
      docAndSelection = document.getElementById("doc-and-selection");
      doc = document.getElementById("doc");
      selection = document.getElementById("selection");
    };
    reader.readAsText(file);
  };
  var importButton = document.getElementById("import-button");
  var importInput = document.getElementById("import-input");
  importButton.onclick = function(e) {
    e.stopPropagation();
    toggleMenu();
    importInput.click();
  };
  importInput.onchange = function(e) {
    var file = importInput.files[0];
    importFile(file);
  };
  var saveButton = document.getElementById("save-button");
  saveButton.onclick = function(e) {
    e.stopPropagation();
    toggleMenu();
    fileOutput.removeAttribute('href'); // don't include recursive copies
    // don't include cursor image
    var oldStyle = svg.getAttribute('style');
    svg.removeAttribute('style');
    var everything = "<!DOCTYPE html>\n" + document.documentElement.outerHTML + "\n";
    everything = everything.
      // get rid of unneccessary xmlns:xlink declaration on each <use>
      replace(/<use xmlns:xlink="http:\/\/www.w3.org\/1999\/xlink" xlink:href="/g, '<use xlink:href="').
      // get rid of extra whitespace before body end tag
      replace(/\s+<\/body>/, "\n</body>");
    fileOutput.href = 'data:text/html;charset=utf-8,' + encodeURIComponent(everything);
    fileOutput.click();
    // restore cursor
    svg.setAttribute('style', oldStyle);
  };
  var helpButton = document.getElementById("help-button");
  helpButton.onclick = function(e) {
    e.stopPropagation();
    toggleMenu();
    show(helpWindow);
  };
  var collaborateButton = document.getElementById("collaborate-button");
  collaborateButton.onclick = function(e) {
    e.stopPropagation();
    toggleMenu();
    show(collaborateWindow);
  };
  var settingsButton = document.getElementById("settings-button");
  settingsButton.onclick = function(e) {
    e.stopPropagation();
    toggleMenu();
    show(settingsWindow);
  };
  var mainToolbar = document.getElementById("main-toolbar");
  forEachToolbarButton(mainToolbar, function(button) {
    var iconUse = button.childNodes[button.childNodes.length - 2];
    var href = iconUse.getAttributeNS('http://www.w3.org/1999/xlink', 'href');
    var iconName = href.toString().replace(/^#/,'');
    var toolName = iconName.replace(/-icon$/,'');
    if (isButtonClicked(button)) {
      currentTool = toolName;
      iconToCursor(iconName, function(style) { svg.setAttribute('style', style); });
    }
    button.onclick = function(e) {
      e.stopPropagation();
      if ((currentTool == 'select' || currentTool == 'copy') &&
	 !(toolName == 'select' || toolName == 'copy')) {
	anchorSelection();
      } else if (currentTool == 'text' && toolName != 'text' && textToolInput.style.display != 'none') {
	finishTextInput();
      }
      currentTool = toolName;
      iconToCursor(iconName, function(style) { svg.setAttribute('style', style); });
      console.log("current tool is now " + currentTool);
      makeToolbarUnclicked(mainToolbar);
      makeButtonClicked(button);
    };
    return true;
  });
  forEachToolbarButton(sizeToolbar, function(button) {
    var circle = button.childNodes[button.childNodes.length - 2];
    var size = circle.getAttribute('r');
    if (isButtonClicked(button)) {
      currentSize = size;
    }
    button.onclick = onSizeButtonClick.bind(this, button);
    return true;
  });
  forEachToolbarButton(colorToolbar, function(button) {
    if (isButtonClicked(button)) {
      switchColor(button);
    }
    button.onclick = onColorButtonClick.bind(this, button);
    return true;
  });
  deleteButton.onclick = function(e) {
    e.stopPropagation();
    startAction(new DeleteObjects());
    // remove connections to the selection
    removeSelectionConnections();
    // remove all children of the selection node
    removeAllChildren(selection);
    finishAction();
  }
  undoButton.onclick = undoAction;
  redoButton.onclick = redoAction;
  var uiGroup = document.getElementById("ui");
  uiGroup.onmouseover = function() {
    mouseIsOverUI = true;
  }
  uiGroup.onmouseout = function() {
    mouseIsOverUI = false;
  }

  document.onkeydown = onkeydown;
  svg.onmousedown = onMouseDownOrClick.bind(this, 'onmousedown');
  svg.onmousemove = onmousemove;
  svg.onwheel = onwheel;
  svg.onmouseup = onmouseup;
  svg.onclick = onMouseDownOrClick.bind(this, 'onclick');
  var epd = function(e) { e.preventDefault() };
  // prevent dragging from the document
  svg.ondragstart = epd
  // enable dragging to the document (confusing, innit?)
  svg.ondragenter = epd;
  svg.ondragover = epd;
  // actually handle a drop
  svg.ondrop = ondrop;
  doc.onmousedown = onMouseDownOrClick.bind(this, 'ondocmousedown');
  selection.onmousedown = onMouseDownOrClick.bind(this, 'onselectionmousedown');
  textChatInput.onkeyup = onTextChatInputKeyUp;

  if (window.location.hash) {
    var userNames = window.location.hash.substr(1).split(/\+/);
    localUserName.value = userNames[0];
    document.getElementById('remote-user-1-name').value = userNames[1];
    startCollaborating(userNames[1]);
  }
}
</script>
</head>
<body>
<canvas id="cursor-canvas" class="invisible" width="32" height="32"></canvas>
<input id="file-input" class="invisible" type="file">
<input id="import-input" class="invisible" type="file">
<a id="file-output" class="invisible" download="whiteboard.html">whiteboard.html</a>
<div id="svg-container" style="bottom: 0px">
<svg>
 <defs>
  <filter id="shadow" filterUnits="userSpaceOnUse" x="0" y="0" width="100%" height="100%">
   <feOffset result="offset" in="SourceAlpha" dx="2" dy="2"></feOffset>
   <feGaussianBlur result="blur" in="offset" stdDeviation="3"></feGaussianBlur>
   <feBlend in="SourceGraphic" in2="blur" mode="normal"></feBlend>
  </filter>
  <filter id="outline" filterUnits="userSpaceOnUse" x="-10%" y="-10%" width="120%" height="120%">
   <feMorphology result="dilation" in="SourceAlpha" operator="dilate" radius="1"></feMorphology>
   <feColorMatrix result="whiteDilation" in="dilation" type="matrix" values="-1 0 0 0 1  0 -1 0 0 1  0 0 -1 0 1  0 0 0 1 0"></feColorMatrix>
   <feBlend in="SourceGraphic" in2="whiteDilation" mode="normal"></feBlend>
  </filter>
  <filter id="fat-outline" filterUnits="userSpaceOnUse" x="-10%" y="-10%" width="120%" height="120%">
   <feMorphology result="dilation" in="SourceAlpha" operator="dilate" radius="5"></feMorphology>
   <feColorMatrix result="whiteDilation" in="dilation" type="matrix" values="-1 0 0 0 1  0 -1 0 0 1  0 0 -1 0 1  0 0 0 1 0"></feColorMatrix>
   <feGaussianBlur result="blur" in="whiteDilation" stdDeviation="3"></feGaussianBlur>
   <feBlend in="SourceGraphic" in2="blur" mode="normal"></feBlend>
  </filter>
  <rect id="icon-frame" x="0" y="0" width="32" height="32"></rect>
  <text id="move-icon" class="icon" x="1px" y="2.2ex" font-weight="bold">
   <tspan></tspan><tspan dx="-0.5em"></tspan><tspan dx="-1em" dy="-0.5ex"></tspan><tspan dx="-1.1ex" dy="1ex"></tspan>
  </text>
  <text id="save-icon" class="icon" x="4px" y="2ex">
   <tspan></tspan><tspan dx="-2.25ex" dy="-0.25ex" stroke="black" fill="#0c0"></tspan><tspan x="3ex" dy="0.25ex"> Save...</tspan>
  </text>
  <text id="import-icon" class="icon" x="1px" y="2ex"><tspan dy="6px" font-size="24pt"></tspan><tspan dx="-1.5ex" stroke="black" fill="#0c0"></tspan><tspan x="3ex" dy="-6px"> Import...</tspan></text><!-- DOCUMENT WITH PICTURE -->
  <text id="open-icon" class="icon" x="4px" y="2ex">
   <tspan></tspan><tspan dx="-0.75ex" dy="-0.25ex" stroke="black" fill="#0c0"></tspan><tspan x="3ex" dy="0.25ex"> Open...</tspan>
  </text>
  <text id="draw-icon" x="2px" y="1.85ex" font-size="20pt" hotspot="4 24"></text><!-- LOWER LEFT PENCIL -->
  <text id="text-icon" x="4px" y="1.75ex" font-size="24pt" hotspot="6 6">T</text>
  <text id="new-icon" class="icon" x="6px" y="2ex"><tspan dy="0.5ex" font-size="24pt"></tspan><tspan x="3ex" dy="-0.5ex"> New</tspan></text><!-- EMPTY DOCUMENT -->
  <text id="settings-icon" class="icon" x="6px" y="2ex"><tspan x="3ex"> Settings...</tspan></text>
  <!-- TODO better collaborate-icon -->
  <text id="collaborate-icon" class="icon" x="8px" y="3.25ex"><tspan font-size="24pt">*</tspan><tspan x="3ex" dy="-1.25ex"> Collaborate...</tspan></text>
  <text id="help-icon" class="icon" x="8px" y="2.6ex"><tspan font-size="24pt">?</tspan><tspan x="3ex" dy="-0.6ex"> Help...</tspan></text>
  <text id="connect-icon" class="icon" x="4px" y="2ex" font-weight="bold" hotspot="8 24"></text>
  <text id="connect-dragging-icon" class="icon" x="4px" y="2ex" font-weight="bold" hotspot="24 8"></text>
  <path id="select-icon" class="icon" d="M 6 10 H 26 V 26 H 10 V 6" hotspot="10 10"></path>
  <text id="delete-icon" x="6px" y="1.75ex" font-size="24pt"></text><!-- WASTEBASKET -->
  <text id="undo-icon" class="icon" x="6px" y="2ex"></text><!-- ANTICLOCKWISE TOP SEMICIRCLE ARROW -->
  <text id="redo-icon" class="icon" x="6px" y="2ex"></text><!-- RIGHTWARDS ARROW WITH HOOK -->
  <text id="copy-icon" class="icon" x="4px" y="1.75ex" hotspot="6 6">
   <tspan></tspan>
   <tspan dx="-1.25ex" dy="0.5ex"></tspan>
  </text>
  <text id="zoom-in-icon" class="icon" x="2px" y="2ex" hotspot="10 10">
   <tspan></tspan>
   <tspan dx="-1ex"></tspan>
  </text>
  <text id="zoom-out-icon" class="icon" x="2px" y="2ex" hotspot="10 10">
   <tspan></tspan>
   <tspan dx="-1ex"></tspan>
  </text>
  <text id="menu-icon" x="4px" y="1.75ex" font-size="24pt"></text>
  <marker id="arrow-head" viewBox="0 0 10 10" refX="5" refY="5" markerUnits="strokeWidth" markerWidth="4" markerHeight="3" orient="auto">
   <path d="M 0 0 L 10 5 L 0 10 z" stroke="context-stroke"/><!-- NOTE: context-stroke is from SVG2, and as of this writing it is not implemented in Firefox or Chrome. It doesn't hurt to include it though. -->
  </marker>
 </defs>
 <rect id="background" x="0" y="0" width="100%" height="100%" fill="white"></rect>
 <g id="doc-and-selection">
  <g id="doc" transform="translate(0,0) scale(1 1)"></g>
  <g id="selection-filter">
   <g id="selection" transform="translate(0,0) scale(1 1)"></g>
  </g>
 </g>
 <g id="fisheye-borders" style="display: none;">
  <!-- original measurements for 100x100 screen, to be updated each time fisheyeis activated -->
  <clipPath id="fecp-00"><rect x="0" y="0" width="10" height="10"></rect></clipPath>
  <symbol id="fes-00">
   <use xlink:href="#background"></use>
   <use id="feu-00" xlink:href="#doc-and-selection" transform="translate(5,5) scale(0.5,0.5)"></use>
  </symbol>
  <use xlink:href="#fes-00" style="clip-path: url(#fecp-00)"></use>

  <clipPath id="fecp-01"><rect x="0" y="10" width="10" height="80"></rect></clipPath>
  <symbol id="fes-01">
   <use xlink:href="#background"></use>
   <use id="feu-01" xlink:href="#doc-and-selection" transform="translate(5,0) scale(0.5,1)"></use>
  </symbol>
  <use xlink:href="#fes-01" style="clip-path: url(#fecp-01)"></use>

  <clipPath id="fecp-02"><rect x="0" y="90" width="10" height="10"></rect></clipPath>
  <symbol id="fes-02">
   <use xlink:href="#background"></use>
   <use id="feu-02" xlink:href="#doc-and-selection" transform="translate(5,45) scale(0.5,0.5)"></use>
  </symbol>
  <use xlink:href="#fes-02" style="clip-path: url(#fecp-02)"></use>


  <clipPath id="fecp-10"><rect x="10" y="0" width="80" height="10"></rect></clipPath>
  <symbol id="fes-10">
   <use xlink:href="#background"></use>
   <use id="feu-10" xlink:href="#doc-and-selection" transform="translate(0,5) scale(1,0.5)"></use>
  </symbol>
  <use xlink:href="#fes-10" style="clip-path: url(#fecp-10)"></use>

  <clipPath id="fecp-12"><rect x="10" y="90" width="80" height="10"></rect></clipPath>
  <symbol id="fes-12">
   <use xlink:href="#background"></use>
   <use id="feu-12" xlink:href="#doc-and-selection" transform="translate(0,45) scale(1,0.5)"></use>
  </symbol>
  <use xlink:href="#fes-12" style="clip-path: url(#fecp-12)"></use>


  <clipPath id="fecp-20"><rect x="90" y="0" width="10" height="10"></rect></clipPath>
  <symbol id="fes-20">
   <use xlink:href="#background"></use>
   <use id="feu-20" xlink:href="#doc-and-selection" transform="translate(45,5) scale(0.5,0.5)"></use>
  </symbol>
  <use xlink:href="#fes-20" style="clip-path: url(#fecp-20)"></use>

  <clipPath id="fecp-21"><rect x="90" y="10" width="10" height="80"></rect></clipPath>
  <symbol id="fes-21">
   <use xlink:href="#background"></use>
   <use id="feu-21" xlink:href="#doc-and-selection" transform="translate(45,0) scale(0.5,1)"></use>
  </symbol>
  <use xlink:href="#fes-21" style="clip-path: url(#fecp-21)"></use>

  <clipPath id="fecp-22"><rect x="90" y="90" width="10" height="10"></rect></clipPath>
  <symbol id="fes-22">
   <use xlink:href="#background"></use>
   <use id="feu-22" xlink:href="#doc-and-selection" transform="translate(45,45) scale(0.5,0.5)"></use>
  </symbol>
  <use xlink:href="#fes-22" style="clip-path: url(#fecp-22)"></use>
  <rect id="fisheye-shadow" x="0" y="0" width="1" height="1" fill="none" stroke-width="0.2" stroke="black" stroke-opacity="0.25"></rect>
 </g>
 <g id="ui">
  <rect id="select-rect" style="display: none;" x="0" y="0" width="0" height="0"></rect>
  <g id="menu" class="popup" style="display: none;">
   <line x1="32" y1="32" x2="48" y2="48" stroke="black" stroke-width="3px"></line>
   <g id="new-button" transform="translate(48,48)">
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <use xlink:href="#new-icon" class="unclicked icon"></use>
   </g>
   <g id="open-button" transform="translate(48,80)">
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <use xlink:href="#open-icon" class="unclicked icon"></use>
   </g>
   <g id="import-button" transform="translate(48,112)">
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <use xlink:href="#import-icon" class="unclicked icon"></use>
   </g>
   <g id="save-button" transform="translate(48,144)">
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <use xlink:href="#save-icon" class="unclicked icon"></use>
   </g>
   <g id="settings-button" transform="translate(48,176)">
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <use xlink:href="#settings-icon" class="unclicked icon"></use>
   </g>
   <g id="collaborate-button" transform="translate(48,208)">
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <use xlink:href="#collaborate-icon" class="unclicked icon"></use>
   </g>
   <g id="help-button" transform="translate(48,240)">
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <use xlink:href="#help-icon" class="unclicked icon"></use>
   </g>
  </g>
  <g id="menu-button" transform="translate(0,0)">
   <use xlink:href="#icon-frame" class="unclicked frame"></use>
   <use xlink:href="#menu-icon" class="unclicked icon"></use>
  </g>
  <!-- left side toolbar -->
  <g id="main-toolbar">
   <g transform="translate(0,64)">
    <title>draw freehand lines</title>
    <use xlink:href="#icon-frame" class="clicked frame"></use>
    <use xlink:href="#draw-icon" class="clicked icon"></use>
   </g>
   <g transform="translate(0,96)">
    <title>add text</title>
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <use xlink:href="#text-icon" class="unclicked icon"></use>
   </g>
   <g transform="translate(0,128)">
    <title>connect objects with arrows</title>
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <use xlink:href="#connect-icon" class="unclicked icon"></use>
   </g>

   <g transform="translate(0,192)">
    <title>select groups of objects and then move them, change their properties, or delete them</title>
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <use xlink:href="#select-icon" class="unclicked icon select-icon-use"></use>
   </g>
   <g transform="translate(0,224)">
    <title>copy objects or selected groups of objects, by dragging</title>
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <use xlink:href="#copy-icon" class="unclicked icon"></use>
   </g>

   <g transform="translate(0,288)">
    <title>pan</title>
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <use xlink:href="#move-icon" class="unclicked icon"></use>
   </g>
   <g transform="translate(0,320)">
    <title>zoom in</title>
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <use xlink:href="#zoom-in-icon" class="unclicked icon"></use>
   </g>
   <g transform="translate(0,368)">
    <title>zoom out</title>
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <use xlink:href="#zoom-out-icon" class="unclicked icon"></use>
   </g>
  </g>
  <!-- top side properties bar -->
  <!-- sizes -->
  <g id="size-toolbar">
   <g transform="translate(64,0)">
    <title>set pen width</title>
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <circle cx="16" cy="16" r="9" class="unclicked icon"></circle>
   </g>
   <g transform="translate(96,0)">
    <title>set pen width</title>
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <circle cx="16" cy="16" r="7" class="unclicked icon"></circle>
   </g>
   <g transform="translate(128,0)">
    <title>set pen width</title>
    <use xlink:href="#icon-frame" class="clicked frame"></use>
    <circle cx="16" cy="16" r="5" class="clicked icon"></circle>
   </g>
   <g transform="translate(160,0)">
    <title>set pen width</title>
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <circle cx="16" cy="16" r="3" class="unclicked icon"></circle>
   </g>
   <g transform="translate(192,0)">
    <title>set pen width</title>
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <circle cx="16" cy="16" r="1" class="unclicked icon"></circle>
   </g>
  </g>
  <!-- colors -->
  <g id="color-toolbar">
   <title>set pen color</title>
   <g transform="translate(256,0)">
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <circle cx="16" cy="16" r="10" class="unclicked color" fill="#c00000"></circle>
   </g>
   <g transform="translate(288,0)">
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <circle cx="16" cy="16" r="10" class="unclicked color" fill="#c0c000"></circle>
   </g>
   <g transform="translate(320,0)">
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <circle cx="16" cy="16" r="10" class="unclicked color" fill="#00c000"></circle>
   </g>
   <g transform="translate(352,0)">
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <circle cx="16" cy="16" r="10" class="unclicked color" fill="#00c0c0"></circle>
   </g>
   <g transform="translate(384,0)">
    <use xlink:href="#icon-frame" class="clicked frame"></use>
    <circle cx="16" cy="16" r="10" class="clicked color" fill="#0000c0"></circle>
   </g>
   <g transform="translate(416,0)">
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <circle cx="16" cy="16" r="10" class="unclicked color" fill="#c000c0"></circle>
   </g>
   <g transform="translate(448,0)">
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <circle cx="16" cy="16" r="10" class="unclicked color" fill="#000000"></circle>
   </g>
  </g>

  <text id="zoom-factor" transform="translate(0,366)">1x</text>

  <g id="actions-toolbar" transform="translate(512,0)">
   <g id="delete-button">
    <title>delete selected group of objects</title>
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <use xlink:href="#delete-icon" class="unclicked icon"></use>
   </g>
   <g id="undo-button" transform="translate(32,0)">
    <title>undo previous action</title>
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <use xlink:href="#undo-icon" class="unclicked icon"></use>
   </g>
   <g id="redo-button" transform="translate(64,0)">
    <title>redo next undone action</title>
    <use xlink:href="#icon-frame" class="unclicked frame"></use>
    <use xlink:href="#redo-icon" class="unclicked icon"></use>
   </g>
  </g>
 </g>
</svg>
</div>
<div id="collaboration-bar" style="display: none;">
 <div id="text-chat">
  <div id="text-chat-history"></div>
  <input type="text" id="text-chat-input">
 </div>
 <div id="user-status">
  <ul id="user-status-list" class="user-status-list">
  </ul>
 </div>
</div>
<textarea id="text-tool-input" style="display: none;" placeholder="Enter text here and click elsewhere when done."></textarea>
<div id="help-window" class="popup" style="display: none;">
 <div class="close" onclick="hide(helpWindow)">X</div>
 <h1><a href="https://github.com/wdebeaum/svg-whiteboard">SVG Whiteboard</a></h1>
 <p>Written by <a href="http://www.uofr.net/~willdb/">William de Beaumont</a></p>
 <p>SVG Whiteboard is a simple drawing application written as a standalone webpage. It requires no external resources besides a reasonably modern web browser. So you can download it, and use it from your own computer without even being connected to the Internet. You can save your work to a file on your computer, and that file will also contain the complete application. If you send that file to someone else, they will be able to open and edit it in the same way you did: with just a web browser.</p>
 <h2>Tools</h2>
 <p>Along the left side (not counting the menu button at the top), there are tools you can use to draw, edit what you've drawn, and navigate your (infinite) whiteboard. Only one of these tools is active at a time; it will appear in white on a black background, and your pointer will change to become its icon. The tools are:</p>
 <dl>
  <dt><svg class="inline icon"><use xlink:href="#draw-icon"></use></svg> Draw</dt>
   <dd>Draw freehand lines by dragging your pointer.</dd>
  <dt><svg class="inline icon"><use xlink:href="#text-icon"></use></svg> Text</dt>
   <dd>Click where you want the text to start, and type. Click elsewhere to finish. You can also click on a previously added piece of text to re-open it.</dd>
  <dt><svg class="inline icon"><use xlink:href="#connect-icon"></use></svg> Connect</dt>
   <dd>Connects existing objects (drawn lines, texts, or imported images) with straight arrows, which move along with the objects they are connected to. Note that you start dragging using the tail of the arrow cursor, and finish with the head.</dd>
  <dt><svg class="inline icon select-icon-use unclicked"><use xlink:href="#select-icon"></use></svg> Select</dt>
   <dd>Click on an object to select only that object, or drag a box around a group of objects to select all of them. Selected objects will have a drop shadow. Drag any selected object to move the whole selection.</dd>
  <dt><svg class="inline icon"><use xlink:href="#copy-icon"></use></svg> Copy</dt>
   <dd>Drag from an object (or the selection) to make a copy of that object and move it to where you want it.</dd>
  <dt><svg class="inline icon"><use xlink:href="#move-icon"></use></svg> Pan</dt>
   <dd>Drag to move the whiteboard itself. It is practically infinite in size, so you can always find more space to draw on this way. You can also pan using your mouse's scrollwheel or trackpad's scroll gestures, with any tool except zoom in/out. While panning, a fisheye effect is applied to the borders, allowing you to see areas just beyond the edge of the screen by squashing them towards the center. The area that won't be visible when you stop panning is darkened slightly, so you can still align with the edges of the screen.</dd>
  <dt><svg class="inline icon"><use xlink:href="#zoom-in-icon"></use></svg> Zoom in / <svg class="inline icon"><use xlink:href="#zoom-out-icon"></use></svg> Zoom out</dt>
   <dd>Click to zoom in or out (depending on which tool is active) by a factor of 2. You can also scroll up/down to zoom in/out with either tool active. The current zoom factor is displayed between the two tools.</dd>
 </dl>
 <h2>Properties</h2>
 <p>Along the top, there are buttons for choosing values for two properties:</p>
 <dl>
  <dt><svg class="inline icon"><circle cx="16" cy="16" r="5" class="unclicked icon"></circle></svg> Size</dt>
   <dd>The size of the pen used for drawing freehand lines or connecting arrows. This also controls the font size used for typed text (but not the size of the pen used to draw the lines that make up the text).</dd>
  <dt><svg class="inline icon"><circle cx="16" cy="16" r="10" class="unclicked color" fill="#00c"></circle></svg> Color</dt>
   <dd>The color used for drawing lines, text, and connecting arrows.</dd>
 </dl>
 <p>If you change one of these properties after selecting objects with the select tool, those objects will be updated to reflect the new property value you chose. For example, if you selected a thin blue line, and then chose a thicker pen size, that line would then be a thick blue line. If you then chose the red pen color, the line would turn red.</p>
 <h2>Actions</h2>
 <p>Also along the top, to the right of the color palette, there are a few action buttons. These do something each time you click the button, as opposed to the tools, which only affect how you interact with the whiteboard.</p>
 <dl>
  <dt><svg class="inline icon"><use xlink:href="#delete-icon"></use></svg> Delete</dt>
   <dd>Deletes any objects you have selected from the whiteboard.</dd>
  <dt><svg class="inline icon"><use xlink:href="#undo-icon"></use></svg> Undo</dt>
   <dd>Undoes the last thing you did. Doing this multiple times goes further and further back into the history of your current editing session. Ctrl-Z does the same thing.</dd>
  <dt><svg class="inline icon"><use xlink:href="#redo-icon"></use></svg> Redo</dt>
   <dd>Undoes undo, going forward in the history. Ctrl-Y does the same thing.</dd>
 </dl>
 <h2>Menu</h2>
 <p>If you're reading this, you've probably already found the <svg class="inline icon"><use xlink:href="#menu-icon"></use></svg> <b>Menu</b> button in the top left corner. The menu has these items to choose from:</p>
 <dl>
  <dt><svg class="inline icon"><use xlink:href="#new-icon"></use></svg> New</dt>
   <dd>Deletes everything from the whiteboard. Save first if you want to keep your previous drawing!</dd>
  <dt><svg class="inline icon"><use xlink:href="#open-icon"></use></svg> Open...</dt>
   <dd>Lets you load the contents of a whiteboard you previously saved. Loading the file directly into your web browser will have essentially the same effect.</dd>
  <dt><svg class="inline icon"><use xlink:href="#import-icon"></use></svg> Import...</dt>
   <dd>Lets you load an image or text file as an object to place on the whiteboard. Text files become normal text objects that you can edit. You can also import text by dragging and dropping onto the whiteboard. In Chrome and Opera, you can import local images by dragging and dropping. In other browsers, and with non-local images, you will get the URL of the image as text instead.</dd>
  <dt><svg class="inline icon"><use xlink:href="#save-icon"></use></svg> Save...</dt>
   <dd>Lets you save the whiteboard (both the contents <em>and the application itself</em>) to your computer.</dd>
  <dt><svg class="inline icon"><use xlink:href="#settings-icon"></use></svg> Settings...</dt>
   <dd>Lets you adjust settings related to the operation of this application, including the color palette, scrolling speed and direction, the fisheye panning effect, and WebRTC (used for collaboration).</dd>
  <dt><svg class="inline icon"><use xlink:href="#collaborate-icon"></use></svg> Collaborate... (WIP)</dt>
   <dd>Lets you collaborate with other users across the Internet. Enter your name and the remote users' names. Use the "+ add" button to add space for another user, and "- remove" to remove the last one. Send each user the URI that appears below their name. Click the " start collaborating" button, and when they go to the URI you sent them in their browser, you will be connected. Whatever you have drawn so far will be sent to them, and whatever either of you draws, the other will see. A text chat will also appear at the bottom of the page. <ul class="user-status-list demo"><li class="active"><span>active</span></li><li class="inactive"><span>inactive</span></li><li class="disconnected"><span>disconnected</span></li></ul> To the right of that there is a list of users indicating each one's connection status (see the key to the right). When you are done, you can go back to the Collaborate window and click the " stop collaborating" button.</dd>
  <dt><svg class="inline icon"><use xlink:href="#help-icon"></use></svg> Help...</dt>
   <dd>Displays this help window.</dd>
 </dl>
 <p>Most menu items (those ending with "...") open a new window. Those dealing with files use your browser's file chooser. The others open a window in the webpage. Click the red X button at the top right to close this second type of window.</p>
 <h2>Technowledgements</h2>
 <p>SVG Whiteboard was written using <a href="http://www.w3.org/Graphics/SVG/">SVG</a> (natch) embedded in <a href="http://www.w3.org/TR/html5/">HTML5</a>, and makes good use of <a href="https://www.w3.org/Style/CSS/">CSS</a>, <a href="http://www.ecmascript.org/">ECMAScript (aka JavaScript)</a>, <a href="http://tools.ietf.org/html/rfc2397">Data URIs</a>, the <a href="https://www.w3.org/TR/FileAPI/">File API</a>, <a href="https://webrtc.org/">WebRTC</a>, and <a href="http://www.unicode.org/">Unicode</a>. It also embeds an excerpt of the <a href="http://users.teilar.gr/~g1951d/">Symbola</a> font (as a data URI). The full font has glyphs for practically all the symbols in Unicode, and is "free for any use". I use just the ASCII part part plus some extra Latin and Greek characters, and glyphs for most of the tool and menu icons in this application.</p>
</div>
<div id="settings-window" class="popup" style="display: none;">
 <div class="close" onclick="hide(settingsWindow)">X</div>
 <h1>Settings</h1>
 <label>Current color is <input id="color-input" type="color" value="#0000c0" onchange="changeCurrentColor(this.value)">.</label>
 <button onclick="addColor()">+ add</button>
 <button onclick="removeCurrentColor()">- remove</button>
 <hr>
 <label>Horizontal scroll wheel/gesture pans by <input id="pan-scroll-x" type="number" value="53"> pixels (enter a negative number to reverse direction).</label><br>
 <label>Vertical scroll wheel/gesture pans by <input id="pan-scroll-y" type="number" value="53"> pixels.</label><br>
 <label><input id="invert-scroll-zoom" type="checkbox"> Reverse direction of zooming with vertical scroll wheel/gesture.</label><br>
 <label>Zooming in once makes things appear <input id="zoom-step" type="number" value="2">x bigger.</label>
 <hr>
 <label><input id="enable-fisheye" type="checkbox" onchange="setDisplay(fisheyeSettings, this.checked)" checked> Enable fisheye effect while panning.</label>
 <div id="fisheye-settings">
  <label>Borders show <input id="fisheye-border-squash" type="number" min="1" value="3">x what they normally do, squashed in from beyond the screen.</label><br>
  <label>Each border is thick enough to use <input id="fisheye-border-thickness" type="number" min="0" max="50" value="15">% of the screen.</label><br>
  <label>Continue fisheye effect for <input id="fisheye-timeout" type="number" min="0" value="250"> milliseconds after panning with scroll wheel/gesture.</label>
   <!-- TODO preview? -->
 </div>
 <hr>
 <label>WebRTC signaling relay URI:<br>
  <input type="url" id="signaling-relay-uri" value="https://ssl.uofr.net/~willdb/cgi-bin/relay.pl">
 </label>
 <label>ICE (STUN/TURN) server list:<br>
 <textarea id="ice-servers" placeholder="Enter the JSON array to pass in the iceServers argument to RTCPeerConnection.">[
{"urls":"stun:stun.ekiga.net"},
{"urls":"stun:stun.iptel.org"},
{"urls":"stun:stun.l.google.com:19302"},
{"urls":"stun:stun1.l.google.com:19302"},
{"urls":"stun:stun2.l.google.com:19302"},
{"urls":"stun:stun3.l.google.com:19302"},
{"urls":"stun:stun4.l.google.com:19302"}
]</textarea></label>
 <label><input type="checkbox" id="enable-signaling-fallback"> Fall back to using the signaling relay as the main connection if ICE fails.</label>
 <hr>
 <button onclick="restoreDefaultSettings()">restore defaults</button>
</div>
<div id="collaborate-window" class="popup" style="display: none;">
 <div class="close" onclick="hide(collaborateWindow)">X</div>
 <h2>Collaborate</h2>
 <label>My name is <input type="text" id="local-user-name" placeholder="/^[\w-]+$/" onchange="onChangeLocal()"></label>. <button onclick="generateRandomName('local-user-name')">generate random name</button><br>
 <h3>Remote users</h3>
 <label>Blank whiteboard URI:<br>
   <input type="url" id="blank-whiteboard-uri" value="http://www.uofr.net/~willdb/software/whiteboard.html" onchange="onChangeLocal()"></label>
 <ol id="remote-users">
  <li id="remote-user-1-li">Send the user <label>named <input type="text" id="remote-user-1-name" placeholder="/^[\w-]+$/" onfocus="onFocusRemoteUserName(this)" onchange="onChangeRemoteUserName(this)"></label> (<button onclick="generateRandomName('remote-user-1-name')">generate random name</button>) <label>this URI:<br>
    <input type="url" id="remote-user-1-uri" placeholder="Enter both local and remote user names to compute the URI." readonly></label></li>
  <li id="add-remove-user-li"><button onclick="addUser()">+ add</button> <button onclick="removeUser()">- remove</button></li>
 </ol>
 <button onclick="startCollaborating()"> start collaborating</button>
 <button onclick="stopCollaborating()"> stop collaborating</button>
</div>
</body></html>
